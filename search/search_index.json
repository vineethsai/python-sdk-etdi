{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ETDI Security Framework","text":"<p>Enterprise-Grade Security for AI Tool Interactions</p> <p>Prevent tool poisoning, rug poisoning, and unauthorized access with cryptographic verification, behavioral monitoring, and comprehensive audit trails.</p>"},{"location":"#key-security-features","title":"Key Security Features","text":"<ul> <li>\ud83d\udee1\ufe0f Tool Poisoning Prevention: Cryptographic signatures and behavioral verification</li> <li>\ud83d\udc41\ufe0f Rug Poisoning Protection: Change detection and reapproval workflows  </li> <li>\ud83d\udd10 Call Chain Validation: Stack constraints and caller/callee authorization</li> <li>\ud83d\udd11 Enterprise Authentication: OAuth 2.0, SAML, and SSO integration</li> <li>\ud83d\udcca Comprehensive Auditing: Security events, compliance reporting, and forensics</li> <li>\u26a1 Real-time Monitoring: Live threat detection and automated response</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from mcp.etdi import SecureServer, ToolProvider\nfrom mcp.etdi.auth import OAuthHandler\n\n# Create secure server with ETDI protection\nserver = SecureServer(\n    security_level=\"high\",\n    enable_tool_verification=True,\n    enable_behavior_monitoring=True\n)\n\n# Add OAuth authentication\nauth = OAuthHandler(\n    provider=\"auth0\",\n    domain=\"your-domain.auth0.com\",\n    client_id=\"your-client-id\"\n)\nserver.add_auth_handler(auth)\n\n# Register verified tools\n@server.tool(\"secure_file_read\")\nasync def secure_file_read(path: str) -&gt; str:\n    # Tool implementation with ETDI security\n    return await verified_file_read(path)\n</code></pre>"},{"location":"#documentation-structure","title":"Documentation Structure","text":"<ul> <li>Getting Started: Installation, setup, and your first secure server.</li> <li>Attack Prevention: Comprehensive protection against AI security threats.</li> <li>Security Features: Authentication, authorization, and behavioral verification.</li> <li>Examples &amp; Demos: Real-world examples and interactive demonstrations.</li> </ul>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#mcp.ClientSession","title":"ClientSession","text":"<p>               Bases: <code>BaseSession[ClientRequest, ClientNotification, ClientResult, ServerRequest, ServerNotification]</code></p> Source code in <code>src/mcp/client/session.py</code> <pre><code>class ClientSession(\n    BaseSession[\n        types.ClientRequest,\n        types.ClientNotification,\n        types.ClientResult,\n        types.ServerRequest,\n        types.ServerNotification,\n    ]\n):\n    def __init__(\n        self,\n        read_stream: MemoryObjectReceiveStream[SessionMessage | Exception],\n        write_stream: MemoryObjectSendStream[SessionMessage],\n        read_timeout_seconds: timedelta | None = None,\n        sampling_callback: SamplingFnT | None = None,\n        list_roots_callback: ListRootsFnT | None = None,\n        logging_callback: LoggingFnT | None = None,\n        message_handler: MessageHandlerFnT | None = None,\n        client_info: types.Implementation | None = None,\n    ) -&gt; None:\n        super().__init__(\n            read_stream,\n            write_stream,\n            types.ServerRequest,\n            types.ServerNotification,\n            read_timeout_seconds=read_timeout_seconds,\n        )\n        self._client_info = client_info or DEFAULT_CLIENT_INFO\n        self._sampling_callback = sampling_callback or _default_sampling_callback\n        self._list_roots_callback = list_roots_callback or _default_list_roots_callback\n        self._logging_callback = logging_callback or _default_logging_callback\n        self._message_handler = message_handler or _default_message_handler\n\n    async def initialize(self) -&gt; types.InitializeResult:\n        sampling = types.SamplingCapability()\n        roots = types.RootsCapability(\n            # TODO: Should this be based on whether we\n            # _will_ send notifications, or only whether\n            # they're supported?\n            listChanged=True,\n        )\n\n        result = await self.send_request(\n            types.ClientRequest(\n                types.InitializeRequest(\n                    method=\"initialize\",\n                    params=types.InitializeRequestParams(\n                        protocolVersion=types.LATEST_PROTOCOL_VERSION,\n                        capabilities=types.ClientCapabilities(\n                            sampling=sampling,\n                            experimental=None,\n                            roots=roots,\n                        ),\n                        clientInfo=self._client_info,\n                    ),\n                )\n            ),\n            types.InitializeResult,\n        )\n\n        if result.protocolVersion not in SUPPORTED_PROTOCOL_VERSIONS:\n            raise RuntimeError(\n                \"Unsupported protocol version from the server: \"\n                f\"{result.protocolVersion}\"\n            )\n\n        await self.send_notification(\n            types.ClientNotification(\n                types.InitializedNotification(method=\"notifications/initialized\")\n            )\n        )\n\n        return result\n\n    async def send_ping(self) -&gt; types.EmptyResult:\n        \"\"\"Send a ping request.\"\"\"\n        return await self.send_request(\n            types.ClientRequest(\n                types.PingRequest(\n                    method=\"ping\",\n                )\n            ),\n            types.EmptyResult,\n        )\n\n    async def send_progress_notification(\n        self,\n        progress_token: str | int,\n        progress: float,\n        total: float | None = None,\n        message: str | None = None,\n    ) -&gt; None:\n        \"\"\"Send a progress notification.\"\"\"\n        await self.send_notification(\n            types.ClientNotification(\n                types.ProgressNotification(\n                    method=\"notifications/progress\",\n                    params=types.ProgressNotificationParams(\n                        progressToken=progress_token,\n                        progress=progress,\n                        total=total,\n                        message=message,\n                    ),\n                ),\n            )\n        )\n\n    async def set_logging_level(self, level: types.LoggingLevel) -&gt; types.EmptyResult:\n        \"\"\"Send a logging/setLevel request.\"\"\"\n        return await self.send_request(\n            types.ClientRequest(\n                types.SetLevelRequest(\n                    method=\"logging/setLevel\",\n                    params=types.SetLevelRequestParams(level=level),\n                )\n            ),\n            types.EmptyResult,\n        )\n\n    async def list_resources(\n        self, cursor: str | None = None\n    ) -&gt; types.ListResourcesResult:\n        \"\"\"Send a resources/list request.\"\"\"\n        return await self.send_request(\n            types.ClientRequest(\n                types.ListResourcesRequest(\n                    method=\"resources/list\",\n                    cursor=cursor,\n                )\n            ),\n            types.ListResourcesResult,\n        )\n\n    async def list_resource_templates(\n        self, cursor: str | None = None\n    ) -&gt; types.ListResourceTemplatesResult:\n        \"\"\"Send a resources/templates/list request.\"\"\"\n        return await self.send_request(\n            types.ClientRequest(\n                types.ListResourceTemplatesRequest(\n                    method=\"resources/templates/list\",\n                    cursor=cursor,\n                )\n            ),\n            types.ListResourceTemplatesResult,\n        )\n\n    async def read_resource(self, uri: AnyUrl) -&gt; types.ReadResourceResult:\n        \"\"\"Send a resources/read request.\"\"\"\n        return await self.send_request(\n            types.ClientRequest(\n                types.ReadResourceRequest(\n                    method=\"resources/read\",\n                    params=types.ReadResourceRequestParams(uri=uri),\n                )\n            ),\n            types.ReadResourceResult,\n        )\n\n    async def subscribe_resource(self, uri: AnyUrl) -&gt; types.EmptyResult:\n        \"\"\"Send a resources/subscribe request.\"\"\"\n        return await self.send_request(\n            types.ClientRequest(\n                types.SubscribeRequest(\n                    method=\"resources/subscribe\",\n                    params=types.SubscribeRequestParams(uri=uri),\n                )\n            ),\n            types.EmptyResult,\n        )\n\n    async def unsubscribe_resource(self, uri: AnyUrl) -&gt; types.EmptyResult:\n        \"\"\"Send a resources/unsubscribe request.\"\"\"\n        return await self.send_request(\n            types.ClientRequest(\n                types.UnsubscribeRequest(\n                    method=\"resources/unsubscribe\",\n                    params=types.UnsubscribeRequestParams(uri=uri),\n                )\n            ),\n            types.EmptyResult,\n        )\n\n    async def call_tool(\n        self,\n        name: str,\n        arguments: dict[str, Any] | None = None,\n        read_timeout_seconds: timedelta | None = None,\n        progress_callback: ProgressFnT | None = None,\n    ) -&gt; types.CallToolResult:\n        \"\"\"Send a tools/call request with optional progress callback support.\"\"\"\n\n        return await self.send_request(\n            types.ClientRequest(\n                types.CallToolRequest(\n                    method=\"tools/call\",\n                    params=types.CallToolRequestParams(\n                        name=name,\n                        arguments=arguments,\n                    ),\n                )\n            ),\n            types.CallToolResult,\n            request_read_timeout_seconds=read_timeout_seconds,\n            progress_callback=progress_callback,\n        )\n\n    async def list_prompts(self, cursor: str | None = None) -&gt; types.ListPromptsResult:\n        \"\"\"Send a prompts/list request.\"\"\"\n        return await self.send_request(\n            types.ClientRequest(\n                types.ListPromptsRequest(\n                    method=\"prompts/list\",\n                    cursor=cursor,\n                )\n            ),\n            types.ListPromptsResult,\n        )\n\n    async def get_prompt(\n        self, name: str, arguments: dict[str, str] | None = None\n    ) -&gt; types.GetPromptResult:\n        \"\"\"Send a prompts/get request.\"\"\"\n        return await self.send_request(\n            types.ClientRequest(\n                types.GetPromptRequest(\n                    method=\"prompts/get\",\n                    params=types.GetPromptRequestParams(name=name, arguments=arguments),\n                )\n            ),\n            types.GetPromptResult,\n        )\n\n    async def complete(\n        self,\n        ref: types.ResourceReference | types.PromptReference,\n        argument: dict[str, str],\n    ) -&gt; types.CompleteResult:\n        \"\"\"Send a completion/complete request.\"\"\"\n        return await self.send_request(\n            types.ClientRequest(\n                types.CompleteRequest(\n                    method=\"completion/complete\",\n                    params=types.CompleteRequestParams(\n                        ref=ref,\n                        argument=types.CompletionArgument(**argument),\n                    ),\n                )\n            ),\n            types.CompleteResult,\n        )\n\n    async def list_tools(self, cursor: str | None = None) -&gt; types.ListToolsResult:\n        \"\"\"Send a tools/list request.\"\"\"\n        return await self.send_request(\n            types.ClientRequest(\n                types.ListToolsRequest(\n                    method=\"tools/list\",\n                    cursor=cursor,\n                )\n            ),\n            types.ListToolsResult,\n        )\n\n    async def send_roots_list_changed(self) -&gt; None:\n        \"\"\"Send a roots/list_changed notification.\"\"\"\n        await self.send_notification(\n            types.ClientNotification(\n                types.RootsListChangedNotification(\n                    method=\"notifications/roots/list_changed\",\n                )\n            )\n        )\n\n    async def _received_request(\n        self, responder: RequestResponder[types.ServerRequest, types.ClientResult]\n    ) -&gt; None:\n        ctx = RequestContext[ClientSession, Any](\n            request_id=responder.request_id,\n            meta=responder.request_meta,\n            session=self,\n            lifespan_context=None,\n        )\n\n        match responder.request.root:\n            case types.CreateMessageRequest(params=params):\n                with responder:\n                    response = await self._sampling_callback(ctx, params)\n                    client_response = ClientResponse.validate_python(response)\n                    await responder.respond(client_response)\n\n            case types.ListRootsRequest():\n                with responder:\n                    response = await self._list_roots_callback(ctx)\n                    client_response = ClientResponse.validate_python(response)\n                    await responder.respond(client_response)\n\n            case types.PingRequest():\n                with responder:\n                    return await responder.respond(\n                        types.ClientResult(root=types.EmptyResult())\n                    )\n\n    async def _handle_incoming(\n        self,\n        req: RequestResponder[types.ServerRequest, types.ClientResult]\n        | types.ServerNotification\n        | Exception,\n    ) -&gt; None:\n        \"\"\"Handle incoming messages by forwarding to the message handler.\"\"\"\n        await self._message_handler(req)\n\n    async def _received_notification(\n        self, notification: types.ServerNotification\n    ) -&gt; None:\n        \"\"\"Handle notifications from the server.\"\"\"\n        # Process specific notification types\n        match notification.root:\n            case types.LoggingMessageNotification(params=params):\n                await self._logging_callback(params)\n            case _:\n                pass\n</code></pre>"},{"location":"api/#mcp.ClientSession.send_ping","title":"send_ping  <code>async</code>","text":"<pre><code>send_ping() -&gt; EmptyResult\n</code></pre> <p>Send a ping request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def send_ping(self) -&gt; types.EmptyResult:\n    \"\"\"Send a ping request.\"\"\"\n    return await self.send_request(\n        types.ClientRequest(\n            types.PingRequest(\n                method=\"ping\",\n            )\n        ),\n        types.EmptyResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.send_progress_notification","title":"send_progress_notification  <code>async</code>","text":"<pre><code>send_progress_notification(\n    progress_token: str | int,\n    progress: float,\n    total: float | None = None,\n    message: str | None = None,\n) -&gt; None\n</code></pre> <p>Send a progress notification.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def send_progress_notification(\n    self,\n    progress_token: str | int,\n    progress: float,\n    total: float | None = None,\n    message: str | None = None,\n) -&gt; None:\n    \"\"\"Send a progress notification.\"\"\"\n    await self.send_notification(\n        types.ClientNotification(\n            types.ProgressNotification(\n                method=\"notifications/progress\",\n                params=types.ProgressNotificationParams(\n                    progressToken=progress_token,\n                    progress=progress,\n                    total=total,\n                    message=message,\n                ),\n            ),\n        )\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.set_logging_level","title":"set_logging_level  <code>async</code>","text":"<pre><code>set_logging_level(level: LoggingLevel) -&gt; EmptyResult\n</code></pre> <p>Send a logging/setLevel request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def set_logging_level(self, level: types.LoggingLevel) -&gt; types.EmptyResult:\n    \"\"\"Send a logging/setLevel request.\"\"\"\n    return await self.send_request(\n        types.ClientRequest(\n            types.SetLevelRequest(\n                method=\"logging/setLevel\",\n                params=types.SetLevelRequestParams(level=level),\n            )\n        ),\n        types.EmptyResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.list_resources","title":"list_resources  <code>async</code>","text":"<pre><code>list_resources(\n    cursor: str | None = None,\n) -&gt; ListResourcesResult\n</code></pre> <p>Send a resources/list request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def list_resources(\n    self, cursor: str | None = None\n) -&gt; types.ListResourcesResult:\n    \"\"\"Send a resources/list request.\"\"\"\n    return await self.send_request(\n        types.ClientRequest(\n            types.ListResourcesRequest(\n                method=\"resources/list\",\n                cursor=cursor,\n            )\n        ),\n        types.ListResourcesResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.list_resource_templates","title":"list_resource_templates  <code>async</code>","text":"<pre><code>list_resource_templates(\n    cursor: str | None = None,\n) -&gt; ListResourceTemplatesResult\n</code></pre> <p>Send a resources/templates/list request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def list_resource_templates(\n    self, cursor: str | None = None\n) -&gt; types.ListResourceTemplatesResult:\n    \"\"\"Send a resources/templates/list request.\"\"\"\n    return await self.send_request(\n        types.ClientRequest(\n            types.ListResourceTemplatesRequest(\n                method=\"resources/templates/list\",\n                cursor=cursor,\n            )\n        ),\n        types.ListResourceTemplatesResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.read_resource","title":"read_resource  <code>async</code>","text":"<pre><code>read_resource(uri: AnyUrl) -&gt; ReadResourceResult\n</code></pre> <p>Send a resources/read request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def read_resource(self, uri: AnyUrl) -&gt; types.ReadResourceResult:\n    \"\"\"Send a resources/read request.\"\"\"\n    return await self.send_request(\n        types.ClientRequest(\n            types.ReadResourceRequest(\n                method=\"resources/read\",\n                params=types.ReadResourceRequestParams(uri=uri),\n            )\n        ),\n        types.ReadResourceResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.subscribe_resource","title":"subscribe_resource  <code>async</code>","text":"<pre><code>subscribe_resource(uri: AnyUrl) -&gt; EmptyResult\n</code></pre> <p>Send a resources/subscribe request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def subscribe_resource(self, uri: AnyUrl) -&gt; types.EmptyResult:\n    \"\"\"Send a resources/subscribe request.\"\"\"\n    return await self.send_request(\n        types.ClientRequest(\n            types.SubscribeRequest(\n                method=\"resources/subscribe\",\n                params=types.SubscribeRequestParams(uri=uri),\n            )\n        ),\n        types.EmptyResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.unsubscribe_resource","title":"unsubscribe_resource  <code>async</code>","text":"<pre><code>unsubscribe_resource(uri: AnyUrl) -&gt; EmptyResult\n</code></pre> <p>Send a resources/unsubscribe request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def unsubscribe_resource(self, uri: AnyUrl) -&gt; types.EmptyResult:\n    \"\"\"Send a resources/unsubscribe request.\"\"\"\n    return await self.send_request(\n        types.ClientRequest(\n            types.UnsubscribeRequest(\n                method=\"resources/unsubscribe\",\n                params=types.UnsubscribeRequestParams(uri=uri),\n            )\n        ),\n        types.EmptyResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.call_tool","title":"call_tool  <code>async</code>","text":"<pre><code>call_tool(\n    name: str,\n    arguments: dict[str, Any] | None = None,\n    read_timeout_seconds: timedelta | None = None,\n    progress_callback: ProgressFnT | None = None,\n) -&gt; CallToolResult\n</code></pre> <p>Send a tools/call request with optional progress callback support.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def call_tool(\n    self,\n    name: str,\n    arguments: dict[str, Any] | None = None,\n    read_timeout_seconds: timedelta | None = None,\n    progress_callback: ProgressFnT | None = None,\n) -&gt; types.CallToolResult:\n    \"\"\"Send a tools/call request with optional progress callback support.\"\"\"\n\n    return await self.send_request(\n        types.ClientRequest(\n            types.CallToolRequest(\n                method=\"tools/call\",\n                params=types.CallToolRequestParams(\n                    name=name,\n                    arguments=arguments,\n                ),\n            )\n        ),\n        types.CallToolResult,\n        request_read_timeout_seconds=read_timeout_seconds,\n        progress_callback=progress_callback,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.list_prompts","title":"list_prompts  <code>async</code>","text":"<pre><code>list_prompts(\n    cursor: str | None = None,\n) -&gt; ListPromptsResult\n</code></pre> <p>Send a prompts/list request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def list_prompts(self, cursor: str | None = None) -&gt; types.ListPromptsResult:\n    \"\"\"Send a prompts/list request.\"\"\"\n    return await self.send_request(\n        types.ClientRequest(\n            types.ListPromptsRequest(\n                method=\"prompts/list\",\n                cursor=cursor,\n            )\n        ),\n        types.ListPromptsResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.get_prompt","title":"get_prompt  <code>async</code>","text":"<pre><code>get_prompt(\n    name: str, arguments: dict[str, str] | None = None\n) -&gt; GetPromptResult\n</code></pre> <p>Send a prompts/get request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def get_prompt(\n    self, name: str, arguments: dict[str, str] | None = None\n) -&gt; types.GetPromptResult:\n    \"\"\"Send a prompts/get request.\"\"\"\n    return await self.send_request(\n        types.ClientRequest(\n            types.GetPromptRequest(\n                method=\"prompts/get\",\n                params=types.GetPromptRequestParams(name=name, arguments=arguments),\n            )\n        ),\n        types.GetPromptResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.complete","title":"complete  <code>async</code>","text":"<pre><code>complete(\n    ref: ResourceReference | PromptReference,\n    argument: dict[str, str],\n) -&gt; CompleteResult\n</code></pre> <p>Send a completion/complete request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def complete(\n    self,\n    ref: types.ResourceReference | types.PromptReference,\n    argument: dict[str, str],\n) -&gt; types.CompleteResult:\n    \"\"\"Send a completion/complete request.\"\"\"\n    return await self.send_request(\n        types.ClientRequest(\n            types.CompleteRequest(\n                method=\"completion/complete\",\n                params=types.CompleteRequestParams(\n                    ref=ref,\n                    argument=types.CompletionArgument(**argument),\n                ),\n            )\n        ),\n        types.CompleteResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.list_tools","title":"list_tools  <code>async</code>","text":"<pre><code>list_tools(cursor: str | None = None) -&gt; ListToolsResult\n</code></pre> <p>Send a tools/list request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def list_tools(self, cursor: str | None = None) -&gt; types.ListToolsResult:\n    \"\"\"Send a tools/list request.\"\"\"\n    return await self.send_request(\n        types.ClientRequest(\n            types.ListToolsRequest(\n                method=\"tools/list\",\n                cursor=cursor,\n            )\n        ),\n        types.ListToolsResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.send_roots_list_changed","title":"send_roots_list_changed  <code>async</code>","text":"<pre><code>send_roots_list_changed() -&gt; None\n</code></pre> <p>Send a roots/list_changed notification.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def send_roots_list_changed(self) -&gt; None:\n    \"\"\"Send a roots/list_changed notification.\"\"\"\n    await self.send_notification(\n        types.ClientNotification(\n            types.RootsListChangedNotification(\n                method=\"notifications/roots/list_changed\",\n            )\n        )\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSessionGroup","title":"ClientSessionGroup","text":"<p>Client for managing connections to multiple MCP servers.</p> <p>This class is responsible for encapsulating management of server connections. It aggregates tools, resources, and prompts from all connected servers.</p> <p>For auxiliary handlers, such as resource subscription, this is delegated to the client and can be accessed via the session.</p> Example Usage <p>name_fn = lambda name, server_info: f\"{(server_info.name)}-{name}\" async with ClientSessionGroup(component_name_hook=name_fn) as group:     for server_params in server_params:         group.connect_to_server(server_param)     ...</p> Source code in <code>src/mcp/client/session_group.py</code> <pre><code>class ClientSessionGroup:\n    \"\"\"Client for managing connections to multiple MCP servers.\n\n    This class is responsible for encapsulating management of server connections.\n    It aggregates tools, resources, and prompts from all connected servers.\n\n    For auxiliary handlers, such as resource subscription, this is delegated to\n    the client and can be accessed via the session.\n\n    Example Usage:\n        name_fn = lambda name, server_info: f\"{(server_info.name)}-{name}\"\n        async with ClientSessionGroup(component_name_hook=name_fn) as group:\n            for server_params in server_params:\n                group.connect_to_server(server_param)\n            ...\n\n    \"\"\"\n\n    class _ComponentNames(BaseModel):\n        \"\"\"Used for reverse index to find components.\"\"\"\n\n        prompts: set[str] = set()\n        resources: set[str] = set()\n        tools: set[str] = set()\n\n    # Standard MCP components.\n    _prompts: dict[str, types.Prompt]\n    _resources: dict[str, types.Resource]\n    _tools: dict[str, types.Tool]\n\n    # Client-server connection management.\n    _sessions: dict[mcp.ClientSession, _ComponentNames]\n    _tool_to_session: dict[str, mcp.ClientSession]\n    _exit_stack: contextlib.AsyncExitStack\n    _session_exit_stacks: dict[mcp.ClientSession, contextlib.AsyncExitStack]\n\n    # Optional fn consuming (component_name, serverInfo) for custom names.\n    # This is provide a means to mitigate naming conflicts across servers.\n    # Example: (tool_name, serverInfo) =&gt; \"{result.serverInfo.name}.{tool_name}\"\n    _ComponentNameHook: TypeAlias = Callable[[str, types.Implementation], str]\n    _component_name_hook: _ComponentNameHook | None\n\n    def __init__(\n        self,\n        exit_stack: contextlib.AsyncExitStack | None = None,\n        component_name_hook: _ComponentNameHook | None = None,\n    ) -&gt; None:\n        \"\"\"Initializes the MCP client.\"\"\"\n\n        self._tools = {}\n        self._resources = {}\n        self._prompts = {}\n\n        self._sessions = {}\n        self._tool_to_session = {}\n        if exit_stack is None:\n            self._exit_stack = contextlib.AsyncExitStack()\n            self._owns_exit_stack = True\n        else:\n            self._exit_stack = exit_stack\n            self._owns_exit_stack = False\n        self._session_exit_stacks = {}\n        self._component_name_hook = component_name_hook\n\n    async def __aenter__(self) -&gt; Self:\n        # Enter the exit stack only if we created it ourselves\n        if self._owns_exit_stack:\n            await self._exit_stack.__aenter__()\n        return self\n\n    async def __aexit__(\n        self,\n        _exc_type: type[BaseException] | None,\n        _exc_val: BaseException | None,\n        _exc_tb: TracebackType | None,\n    ) -&gt; bool | None:\n        \"\"\"Closes session exit stacks and main exit stack upon completion.\"\"\"\n\n        # Concurrently close session stacks.\n        async with anyio.create_task_group() as tg:\n            for exit_stack in self._session_exit_stacks.values():\n                tg.start_soon(exit_stack.aclose)\n\n        # Only close the main exit stack if we created it\n        if self._owns_exit_stack:\n            await self._exit_stack.aclose()\n\n    @property\n    def sessions(self) -&gt; list[mcp.ClientSession]:\n        \"\"\"Returns the list of sessions being managed.\"\"\"\n        return list(self._sessions.keys())\n\n    @property\n    def prompts(self) -&gt; dict[str, types.Prompt]:\n        \"\"\"Returns the prompts as a dictionary of names to prompts.\"\"\"\n        return self._prompts\n\n    @property\n    def resources(self) -&gt; dict[str, types.Resource]:\n        \"\"\"Returns the resources as a dictionary of names to resources.\"\"\"\n        return self._resources\n\n    @property\n    def tools(self) -&gt; dict[str, types.Tool]:\n        \"\"\"Returns the tools as a dictionary of names to tools.\"\"\"\n        return self._tools\n\n    async def call_tool(self, name: str, args: dict[str, Any]) -&gt; types.CallToolResult:\n        \"\"\"Executes a tool given its name and arguments.\"\"\"\n        session = self._tool_to_session[name]\n        session_tool_name = self.tools[name].name\n        return await session.call_tool(session_tool_name, args)\n\n    async def disconnect_from_server(self, session: mcp.ClientSession) -&gt; None:\n        \"\"\"Disconnects from a single MCP server.\"\"\"\n\n        session_known_for_components = session in self._sessions\n        session_known_for_stack = session in self._session_exit_stacks\n\n        if not session_known_for_components and not session_known_for_stack:\n            raise McpError(\n                types.ErrorData(\n                    code=types.INVALID_PARAMS,\n                    message=\"Provided session is not managed or already disconnected.\",\n                )\n            )\n\n        if session_known_for_components:\n            component_names = self._sessions.pop(session)  # Pop from _sessions tracking\n\n            # Remove prompts associated with the session.\n            for name in component_names.prompts:\n                if name in self._prompts:\n                    del self._prompts[name]\n            # Remove resources associated with the session.\n            for name in component_names.resources:\n                if name in self._resources:\n                    del self._resources[name]\n            # Remove tools associated with the session.\n            for name in component_names.tools:\n                if name in self._tools:\n                    del self._tools[name]\n                if name in self._tool_to_session:\n                    del self._tool_to_session[name]\n\n        # Clean up the session's resources via its dedicated exit stack\n        if session_known_for_stack:\n            session_stack_to_close = self._session_exit_stacks.pop(session)\n            await session_stack_to_close.aclose()\n\n    async def connect_with_session(\n        self, server_info: types.Implementation, session: mcp.ClientSession\n    ) -&gt; mcp.ClientSession:\n        \"\"\"Connects to a single MCP server.\"\"\"\n        await self._aggregate_components(server_info, session)\n        return session\n\n    async def connect_to_server(\n        self,\n        server_params: ServerParameters,\n    ) -&gt; mcp.ClientSession:\n        \"\"\"Connects to a single MCP server.\"\"\"\n        server_info, session = await self._establish_session(server_params)\n        return await self.connect_with_session(server_info, session)\n\n    async def _establish_session(\n        self, server_params: ServerParameters\n    ) -&gt; tuple[types.Implementation, mcp.ClientSession]:\n        \"\"\"Establish a client session to an MCP server.\"\"\"\n\n        session_stack = contextlib.AsyncExitStack()\n        try:\n            # Create read and write streams that facilitate io with the server.\n            if isinstance(server_params, StdioServerParameters):\n                client = mcp.stdio_client(server_params)\n                read, write = await session_stack.enter_async_context(client)\n            elif isinstance(server_params, SseServerParameters):\n                client = sse_client(\n                    url=server_params.url,\n                    headers=server_params.headers,\n                    timeout=server_params.timeout,\n                    sse_read_timeout=server_params.sse_read_timeout,\n                )\n                read, write = await session_stack.enter_async_context(client)\n            else:\n                client = streamablehttp_client(\n                    url=server_params.url,\n                    headers=server_params.headers,\n                    timeout=server_params.timeout,\n                    sse_read_timeout=server_params.sse_read_timeout,\n                    terminate_on_close=server_params.terminate_on_close,\n                )\n                read, write, _ = await session_stack.enter_async_context(client)\n\n            session = await session_stack.enter_async_context(\n                mcp.ClientSession(read, write)\n            )\n            result = await session.initialize()\n\n            # Session successfully initialized.\n            # Store its stack and register the stack with the main group stack.\n            self._session_exit_stacks[session] = session_stack\n            # session_stack itself becomes a resource managed by the\n            # main _exit_stack.\n            await self._exit_stack.enter_async_context(session_stack)\n\n            return result.serverInfo, session\n        except Exception:\n            # If anything during this setup fails, ensure the session-specific\n            # stack is closed.\n            await session_stack.aclose()\n            raise\n\n    async def _aggregate_components(\n        self, server_info: types.Implementation, session: mcp.ClientSession\n    ) -&gt; None:\n        \"\"\"Aggregates prompts, resources, and tools from a given session.\"\"\"\n\n        # Create a reverse index so we can find all prompts, resources, and\n        # tools belonging to this session. Used for removing components from\n        # the session group via self.disconnect_from_server.\n        component_names = self._ComponentNames()\n\n        # Temporary components dicts. We do not want to modify the aggregate\n        # lists in case of an intermediate failure.\n        prompts_temp: dict[str, types.Prompt] = {}\n        resources_temp: dict[str, types.Resource] = {}\n        tools_temp: dict[str, types.Tool] = {}\n        tool_to_session_temp: dict[str, mcp.ClientSession] = {}\n\n        # Query the server for its prompts and aggregate to list.\n        try:\n            prompts = (await session.list_prompts()).prompts\n            for prompt in prompts:\n                name = self._component_name(prompt.name, server_info)\n                prompts_temp[name] = prompt\n                component_names.prompts.add(name)\n        except McpError as err:\n            logging.warning(f\"Could not fetch prompts: {err}\")\n\n        # Query the server for its resources and aggregate to list.\n        try:\n            resources = (await session.list_resources()).resources\n            for resource in resources:\n                name = self._component_name(resource.name, server_info)\n                resources_temp[name] = resource\n                component_names.resources.add(name)\n        except McpError as err:\n            logging.warning(f\"Could not fetch resources: {err}\")\n\n        # Query the server for its tools and aggregate to list.\n        try:\n            tools = (await session.list_tools()).tools\n            for tool in tools:\n                name = self._component_name(tool.name, server_info)\n                tools_temp[name] = tool\n                tool_to_session_temp[name] = session\n                component_names.tools.add(name)\n        except McpError as err:\n            logging.warning(f\"Could not fetch tools: {err}\")\n\n        # Clean up exit stack for session if we couldn't retrieve anything\n        # from the server.\n        if not any((prompts_temp, resources_temp, tools_temp)):\n            del self._session_exit_stacks[session]\n\n        # Check for duplicates.\n        matching_prompts = prompts_temp.keys() &amp; self._prompts.keys()\n        if matching_prompts:\n            raise McpError(\n                types.ErrorData(\n                    code=types.INVALID_PARAMS,\n                    message=f\"{matching_prompts} already exist in group prompts.\",\n                )\n            )\n        matching_resources = resources_temp.keys() &amp; self._resources.keys()\n        if matching_resources:\n            raise McpError(\n                types.ErrorData(\n                    code=types.INVALID_PARAMS,\n                    message=f\"{matching_resources} already exist in group resources.\",\n                )\n            )\n        matching_tools = tools_temp.keys() &amp; self._tools.keys()\n        if matching_tools:\n            raise McpError(\n                types.ErrorData(\n                    code=types.INVALID_PARAMS,\n                    message=f\"{matching_tools} already exist in group tools.\",\n                )\n            )\n\n        # Aggregate components.\n        self._sessions[session] = component_names\n        self._prompts.update(prompts_temp)\n        self._resources.update(resources_temp)\n        self._tools.update(tools_temp)\n        self._tool_to_session.update(tool_to_session_temp)\n\n    def _component_name(self, name: str, server_info: types.Implementation) -&gt; str:\n        if self._component_name_hook:\n            return self._component_name_hook(name, server_info)\n        return name\n</code></pre>"},{"location":"api/#mcp.ClientSessionGroup.__init__","title":"__init__","text":"<pre><code>__init__(\n    exit_stack: AsyncExitStack | None = None,\n    component_name_hook: _ComponentNameHook | None = None,\n) -&gt; None\n</code></pre> <p>Initializes the MCP client.</p> Source code in <code>src/mcp/client/session_group.py</code> <pre><code>def __init__(\n    self,\n    exit_stack: contextlib.AsyncExitStack | None = None,\n    component_name_hook: _ComponentNameHook | None = None,\n) -&gt; None:\n    \"\"\"Initializes the MCP client.\"\"\"\n\n    self._tools = {}\n    self._resources = {}\n    self._prompts = {}\n\n    self._sessions = {}\n    self._tool_to_session = {}\n    if exit_stack is None:\n        self._exit_stack = contextlib.AsyncExitStack()\n        self._owns_exit_stack = True\n    else:\n        self._exit_stack = exit_stack\n        self._owns_exit_stack = False\n    self._session_exit_stacks = {}\n    self._component_name_hook = component_name_hook\n</code></pre>"},{"location":"api/#mcp.ClientSessionGroup.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    _exc_type: type[BaseException] | None,\n    _exc_val: BaseException | None,\n    _exc_tb: TracebackType | None,\n) -&gt; bool | None\n</code></pre> <p>Closes session exit stacks and main exit stack upon completion.</p> Source code in <code>src/mcp/client/session_group.py</code> <pre><code>async def __aexit__(\n    self,\n    _exc_type: type[BaseException] | None,\n    _exc_val: BaseException | None,\n    _exc_tb: TracebackType | None,\n) -&gt; bool | None:\n    \"\"\"Closes session exit stacks and main exit stack upon completion.\"\"\"\n\n    # Concurrently close session stacks.\n    async with anyio.create_task_group() as tg:\n        for exit_stack in self._session_exit_stacks.values():\n            tg.start_soon(exit_stack.aclose)\n\n    # Only close the main exit stack if we created it\n    if self._owns_exit_stack:\n        await self._exit_stack.aclose()\n</code></pre>"},{"location":"api/#mcp.ClientSessionGroup.sessions","title":"sessions  <code>property</code>","text":"<pre><code>sessions: list[ClientSession]\n</code></pre> <p>Returns the list of sessions being managed.</p>"},{"location":"api/#mcp.ClientSessionGroup.prompts","title":"prompts  <code>property</code>","text":"<pre><code>prompts: dict[str, Prompt]\n</code></pre> <p>Returns the prompts as a dictionary of names to prompts.</p>"},{"location":"api/#mcp.ClientSessionGroup.resources","title":"resources  <code>property</code>","text":"<pre><code>resources: dict[str, Resource]\n</code></pre> <p>Returns the resources as a dictionary of names to resources.</p>"},{"location":"api/#mcp.ClientSessionGroup.tools","title":"tools  <code>property</code>","text":"<pre><code>tools: dict[str, Tool]\n</code></pre> <p>Returns the tools as a dictionary of names to tools.</p>"},{"location":"api/#mcp.ClientSessionGroup.call_tool","title":"call_tool  <code>async</code>","text":"<pre><code>call_tool(\n    name: str, args: dict[str, Any]\n) -&gt; CallToolResult\n</code></pre> <p>Executes a tool given its name and arguments.</p> Source code in <code>src/mcp/client/session_group.py</code> <pre><code>async def call_tool(self, name: str, args: dict[str, Any]) -&gt; types.CallToolResult:\n    \"\"\"Executes a tool given its name and arguments.\"\"\"\n    session = self._tool_to_session[name]\n    session_tool_name = self.tools[name].name\n    return await session.call_tool(session_tool_name, args)\n</code></pre>"},{"location":"api/#mcp.ClientSessionGroup.disconnect_from_server","title":"disconnect_from_server  <code>async</code>","text":"<pre><code>disconnect_from_server(session: ClientSession) -&gt; None\n</code></pre> <p>Disconnects from a single MCP server.</p> Source code in <code>src/mcp/client/session_group.py</code> <pre><code>async def disconnect_from_server(self, session: mcp.ClientSession) -&gt; None:\n    \"\"\"Disconnects from a single MCP server.\"\"\"\n\n    session_known_for_components = session in self._sessions\n    session_known_for_stack = session in self._session_exit_stacks\n\n    if not session_known_for_components and not session_known_for_stack:\n        raise McpError(\n            types.ErrorData(\n                code=types.INVALID_PARAMS,\n                message=\"Provided session is not managed or already disconnected.\",\n            )\n        )\n\n    if session_known_for_components:\n        component_names = self._sessions.pop(session)  # Pop from _sessions tracking\n\n        # Remove prompts associated with the session.\n        for name in component_names.prompts:\n            if name in self._prompts:\n                del self._prompts[name]\n        # Remove resources associated with the session.\n        for name in component_names.resources:\n            if name in self._resources:\n                del self._resources[name]\n        # Remove tools associated with the session.\n        for name in component_names.tools:\n            if name in self._tools:\n                del self._tools[name]\n            if name in self._tool_to_session:\n                del self._tool_to_session[name]\n\n    # Clean up the session's resources via its dedicated exit stack\n    if session_known_for_stack:\n        session_stack_to_close = self._session_exit_stacks.pop(session)\n        await session_stack_to_close.aclose()\n</code></pre>"},{"location":"api/#mcp.ClientSessionGroup.connect_with_session","title":"connect_with_session  <code>async</code>","text":"<pre><code>connect_with_session(\n    server_info: Implementation, session: ClientSession\n) -&gt; ClientSession\n</code></pre> <p>Connects to a single MCP server.</p> Source code in <code>src/mcp/client/session_group.py</code> <pre><code>async def connect_with_session(\n    self, server_info: types.Implementation, session: mcp.ClientSession\n) -&gt; mcp.ClientSession:\n    \"\"\"Connects to a single MCP server.\"\"\"\n    await self._aggregate_components(server_info, session)\n    return session\n</code></pre>"},{"location":"api/#mcp.ClientSessionGroup.connect_to_server","title":"connect_to_server  <code>async</code>","text":"<pre><code>connect_to_server(\n    server_params: ServerParameters,\n) -&gt; ClientSession\n</code></pre> <p>Connects to a single MCP server.</p> Source code in <code>src/mcp/client/session_group.py</code> <pre><code>async def connect_to_server(\n    self,\n    server_params: ServerParameters,\n) -&gt; mcp.ClientSession:\n    \"\"\"Connects to a single MCP server.\"\"\"\n    server_info, session = await self._establish_session(server_params)\n    return await self.connect_with_session(server_info, session)\n</code></pre>"},{"location":"api/#mcp.StdioServerParameters","title":"StdioServerParameters","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/mcp/client/stdio/__init__.py</code> <pre><code>class StdioServerParameters(BaseModel):\n    command: str\n    \"\"\"The executable to run to start the server.\"\"\"\n\n    args: list[str] = Field(default_factory=list)\n    \"\"\"Command line arguments to pass to the executable.\"\"\"\n\n    env: dict[str, str] | None = None\n    \"\"\"\n    The environment to use when spawning the process.\n\n    If not specified, the result of get_default_environment() will be used.\n    \"\"\"\n\n    cwd: str | Path | None = None\n    \"\"\"The working directory to use when spawning the process.\"\"\"\n\n    encoding: str = \"utf-8\"\n    \"\"\"\n    The text encoding used when sending/receiving messages to the server\n\n    defaults to utf-8\n    \"\"\"\n\n    encoding_error_handler: Literal[\"strict\", \"ignore\", \"replace\"] = \"strict\"\n    \"\"\"\n    The text encoding error handler.\n\n    See https://docs.python.org/3/library/codecs.html#codec-base-classes for\n    explanations of possible values\n    \"\"\"\n</code></pre>"},{"location":"api/#mcp.StdioServerParameters.command","title":"command  <code>instance-attribute</code>","text":"<pre><code>command: str\n</code></pre> <p>The executable to run to start the server.</p>"},{"location":"api/#mcp.StdioServerParameters.args","title":"args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>args: list[str] = Field(default_factory=list)\n</code></pre> <p>Command line arguments to pass to the executable.</p>"},{"location":"api/#mcp.StdioServerParameters.env","title":"env  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>env: dict[str, str] | None = None\n</code></pre> <p>The environment to use when spawning the process.</p> <p>If not specified, the result of get_default_environment() will be used.</p>"},{"location":"api/#mcp.StdioServerParameters.cwd","title":"cwd  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cwd: str | Path | None = None\n</code></pre> <p>The working directory to use when spawning the process.</p>"},{"location":"api/#mcp.StdioServerParameters.encoding","title":"encoding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>encoding: str = 'utf-8'\n</code></pre> <p>The text encoding used when sending/receiving messages to the server</p> <p>defaults to utf-8</p>"},{"location":"api/#mcp.StdioServerParameters.encoding_error_handler","title":"encoding_error_handler  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>encoding_error_handler: Literal[\n    \"strict\", \"ignore\", \"replace\"\n] = \"strict\"\n</code></pre> <p>The text encoding error handler.</p> <p>See https://docs.python.org/3/library/codecs.html#codec-base-classes for explanations of possible values</p>"},{"location":"api/#mcp.stdio_client","title":"stdio_client  <code>async</code>","text":"<pre><code>stdio_client(\n    server: StdioServerParameters, errlog: TextIO = stderr\n)\n</code></pre> <p>Client transport for stdio: this will connect to a server by spawning a process and communicating with it over stdin/stdout.</p> Source code in <code>src/mcp/client/stdio/__init__.py</code> <pre><code>@asynccontextmanager\nasync def stdio_client(server: StdioServerParameters, errlog: TextIO = sys.stderr):\n    \"\"\"\n    Client transport for stdio: this will connect to a server by spawning a\n    process and communicating with it over stdin/stdout.\n    \"\"\"\n    read_stream: MemoryObjectReceiveStream[SessionMessage | Exception]\n    read_stream_writer: MemoryObjectSendStream[SessionMessage | Exception]\n\n    write_stream: MemoryObjectSendStream[SessionMessage]\n    write_stream_reader: MemoryObjectReceiveStream[SessionMessage]\n\n    read_stream_writer, read_stream = anyio.create_memory_object_stream(0)\n    write_stream, write_stream_reader = anyio.create_memory_object_stream(0)\n\n    command = _get_executable_command(server.command)\n\n    # Open process with stderr piped for capture\n    process = await _create_platform_compatible_process(\n        command=command,\n        args=server.args,\n        env=(\n            {**get_default_environment(), **server.env}\n            if server.env is not None\n            else get_default_environment()\n        ),\n        errlog=errlog,\n        cwd=server.cwd,\n    )\n\n    async def stdout_reader():\n        assert process.stdout, \"Opened process is missing stdout\"\n\n        try:\n            async with read_stream_writer:\n                buffer = \"\"\n                async for chunk in TextReceiveStream(\n                    process.stdout,\n                    encoding=server.encoding,\n                    errors=server.encoding_error_handler,\n                ):\n                    lines = (buffer + chunk).split(\"\\n\")\n                    buffer = lines.pop()\n\n                    for line in lines:\n                        try:\n                            message = types.JSONRPCMessage.model_validate_json(line)\n                        except Exception as exc:\n                            await read_stream_writer.send(exc)\n                            continue\n\n                        session_message = SessionMessage(message)\n                        await read_stream_writer.send(session_message)\n        except anyio.ClosedResourceError:\n            await anyio.lowlevel.checkpoint()\n\n    async def stdin_writer():\n        assert process.stdin, \"Opened process is missing stdin\"\n\n        try:\n            async with write_stream_reader:\n                async for session_message in write_stream_reader:\n                    json = session_message.message.model_dump_json(\n                        by_alias=True, exclude_none=True\n                    )\n                    await process.stdin.send(\n                        (json + \"\\n\").encode(\n                            encoding=server.encoding,\n                            errors=server.encoding_error_handler,\n                        )\n                    )\n        except anyio.ClosedResourceError:\n            await anyio.lowlevel.checkpoint()\n\n    async with (\n        anyio.create_task_group() as tg,\n        process,\n    ):\n        tg.start_soon(stdout_reader)\n        tg.start_soon(stdin_writer)\n        try:\n            yield read_stream, write_stream\n        finally:\n            # Clean up process to prevent any dangling orphaned processes\n            if sys.platform == \"win32\":\n                await terminate_windows_process(process)\n            else:\n                process.terminate()\n            await read_stream.aclose()\n            await write_stream.aclose()\n</code></pre>"},{"location":"api/#mcp.ServerSession","title":"ServerSession","text":"<p>               Bases: <code>BaseSession[ServerRequest, ServerNotification, ServerResult, ClientRequest, ClientNotification]</code></p> Source code in <code>src/mcp/server/session.py</code> <pre><code>class ServerSession(\n    BaseSession[\n        types.ServerRequest,\n        types.ServerNotification,\n        types.ServerResult,\n        types.ClientRequest,\n        types.ClientNotification,\n    ]\n):\n    _initialized: InitializationState = InitializationState.NotInitialized\n    _client_params: types.InitializeRequestParams | None = None\n\n    def __init__(\n        self,\n        read_stream: MemoryObjectReceiveStream[SessionMessage | Exception],\n        write_stream: MemoryObjectSendStream[SessionMessage],\n        init_options: InitializationOptions,\n        stateless: bool = False,\n    ) -&gt; None:\n        super().__init__(\n            read_stream, write_stream, types.ClientRequest, types.ClientNotification\n        )\n        self._initialization_state = (\n            InitializationState.Initialized\n            if stateless\n            else InitializationState.NotInitialized\n        )\n\n        self._init_options = init_options\n        self._incoming_message_stream_writer, self._incoming_message_stream_reader = (\n            anyio.create_memory_object_stream[ServerRequestResponder](0)\n        )\n        self._exit_stack.push_async_callback(\n            lambda: self._incoming_message_stream_reader.aclose()\n        )\n\n    @property\n    def client_params(self) -&gt; types.InitializeRequestParams | None:\n        return self._client_params\n\n    def check_client_capability(self, capability: types.ClientCapabilities) -&gt; bool:\n        \"\"\"Check if the client supports a specific capability.\"\"\"\n        if self._client_params is None:\n            return False\n\n        # Get client capabilities from initialization params\n        client_caps = self._client_params.capabilities\n\n        # Check each specified capability in the passed in capability object\n        if capability.roots is not None:\n            if client_caps.roots is None:\n                return False\n            if capability.roots.listChanged and not client_caps.roots.listChanged:\n                return False\n\n        if capability.sampling is not None:\n            if client_caps.sampling is None:\n                return False\n\n        if capability.experimental is not None:\n            if client_caps.experimental is None:\n                return False\n            # Check each experimental capability\n            for exp_key, exp_value in capability.experimental.items():\n                if (\n                    exp_key not in client_caps.experimental\n                    or client_caps.experimental[exp_key] != exp_value\n                ):\n                    return False\n\n        return True\n\n    async def _receive_loop(self) -&gt; None:\n        async with self._incoming_message_stream_writer:\n            await super()._receive_loop()\n\n    async def _received_request(\n        self, responder: RequestResponder[types.ClientRequest, types.ServerResult]\n    ):\n        match responder.request.root:\n            case types.InitializeRequest(params=params):\n                requested_version = params.protocolVersion\n                self._initialization_state = InitializationState.Initializing\n                self._client_params = params\n                with responder:\n                    await responder.respond(\n                        types.ServerResult(\n                            types.InitializeResult(\n                                protocolVersion=requested_version\n                                if requested_version in SUPPORTED_PROTOCOL_VERSIONS\n                                else types.LATEST_PROTOCOL_VERSION,\n                                capabilities=self._init_options.capabilities,\n                                serverInfo=types.Implementation(\n                                    name=self._init_options.server_name,\n                                    version=self._init_options.server_version,\n                                ),\n                                instructions=self._init_options.instructions,\n                            )\n                        )\n                    )\n            case _:\n                if self._initialization_state != InitializationState.Initialized:\n                    raise RuntimeError(\n                        \"Received request before initialization was complete\"\n                    )\n\n    async def _received_notification(\n        self, notification: types.ClientNotification\n    ) -&gt; None:\n        # Need this to avoid ASYNC910\n        await anyio.lowlevel.checkpoint()\n        match notification.root:\n            case types.InitializedNotification():\n                self._initialization_state = InitializationState.Initialized\n            case _:\n                if self._initialization_state != InitializationState.Initialized:\n                    raise RuntimeError(\n                        \"Received notification before initialization was complete\"\n                    )\n\n    async def send_log_message(\n        self,\n        level: types.LoggingLevel,\n        data: Any,\n        logger: str | None = None,\n        related_request_id: types.RequestId | None = None,\n    ) -&gt; None:\n        \"\"\"Send a log message notification.\"\"\"\n        await self.send_notification(\n            types.ServerNotification(\n                types.LoggingMessageNotification(\n                    method=\"notifications/message\",\n                    params=types.LoggingMessageNotificationParams(\n                        level=level,\n                        data=data,\n                        logger=logger,\n                    ),\n                )\n            ),\n            related_request_id,\n        )\n\n    async def send_resource_updated(self, uri: AnyUrl) -&gt; None:\n        \"\"\"Send a resource updated notification.\"\"\"\n        await self.send_notification(\n            types.ServerNotification(\n                types.ResourceUpdatedNotification(\n                    method=\"notifications/resources/updated\",\n                    params=types.ResourceUpdatedNotificationParams(uri=uri),\n                )\n            )\n        )\n\n    async def create_message(\n        self,\n        messages: list[types.SamplingMessage],\n        *,\n        max_tokens: int,\n        system_prompt: str | None = None,\n        include_context: types.IncludeContext | None = None,\n        temperature: float | None = None,\n        stop_sequences: list[str] | None = None,\n        metadata: dict[str, Any] | None = None,\n        model_preferences: types.ModelPreferences | None = None,\n        related_request_id: types.RequestId | None = None,\n    ) -&gt; types.CreateMessageResult:\n        \"\"\"Send a sampling/create_message request.\"\"\"\n        return await self.send_request(\n            request=types.ServerRequest(\n                types.CreateMessageRequest(\n                    method=\"sampling/createMessage\",\n                    params=types.CreateMessageRequestParams(\n                        messages=messages,\n                        systemPrompt=system_prompt,\n                        includeContext=include_context,\n                        temperature=temperature,\n                        maxTokens=max_tokens,\n                        stopSequences=stop_sequences,\n                        metadata=metadata,\n                        modelPreferences=model_preferences,\n                    ),\n                )\n            ),\n            result_type=types.CreateMessageResult,\n            metadata=ServerMessageMetadata(\n                related_request_id=related_request_id,\n            ),\n        )\n\n    async def list_roots(self) -&gt; types.ListRootsResult:\n        \"\"\"Send a roots/list request.\"\"\"\n        return await self.send_request(\n            types.ServerRequest(\n                types.ListRootsRequest(\n                    method=\"roots/list\",\n                )\n            ),\n            types.ListRootsResult,\n        )\n\n    async def send_ping(self) -&gt; types.EmptyResult:\n        \"\"\"Send a ping request.\"\"\"\n        return await self.send_request(\n            types.ServerRequest(\n                types.PingRequest(\n                    method=\"ping\",\n                )\n            ),\n            types.EmptyResult,\n        )\n\n    async def send_progress_notification(\n        self,\n        progress_token: str | int,\n        progress: float,\n        total: float | None = None,\n        message: str | None = None,\n        related_request_id: str | None = None,\n    ) -&gt; None:\n        \"\"\"Send a progress notification.\"\"\"\n        await self.send_notification(\n            types.ServerNotification(\n                types.ProgressNotification(\n                    method=\"notifications/progress\",\n                    params=types.ProgressNotificationParams(\n                        progressToken=progress_token,\n                        progress=progress,\n                        total=total,\n                        message=message,\n                    ),\n                )\n            ),\n            related_request_id,\n        )\n\n    async def send_resource_list_changed(self) -&gt; None:\n        \"\"\"Send a resource list changed notification.\"\"\"\n        await self.send_notification(\n            types.ServerNotification(\n                types.ResourceListChangedNotification(\n                    method=\"notifications/resources/list_changed\",\n                )\n            )\n        )\n\n    async def send_tool_list_changed(self) -&gt; None:\n        \"\"\"Send a tool list changed notification.\"\"\"\n        await self.send_notification(\n            types.ServerNotification(\n                types.ToolListChangedNotification(\n                    method=\"notifications/tools/list_changed\",\n                )\n            )\n        )\n\n    async def send_prompt_list_changed(self) -&gt; None:\n        \"\"\"Send a prompt list changed notification.\"\"\"\n        await self.send_notification(\n            types.ServerNotification(\n                types.PromptListChangedNotification(\n                    method=\"notifications/prompts/list_changed\",\n                )\n            )\n        )\n\n    async def _handle_incoming(self, req: ServerRequestResponder) -&gt; None:\n        await self._incoming_message_stream_writer.send(req)\n\n    @property\n    def incoming_messages(\n        self,\n    ) -&gt; MemoryObjectReceiveStream[ServerRequestResponder]:\n        return self._incoming_message_stream_reader\n</code></pre>"},{"location":"api/#mcp.ServerSession.check_client_capability","title":"check_client_capability","text":"<pre><code>check_client_capability(\n    capability: ClientCapabilities,\n) -&gt; bool\n</code></pre> <p>Check if the client supports a specific capability.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>def check_client_capability(self, capability: types.ClientCapabilities) -&gt; bool:\n    \"\"\"Check if the client supports a specific capability.\"\"\"\n    if self._client_params is None:\n        return False\n\n    # Get client capabilities from initialization params\n    client_caps = self._client_params.capabilities\n\n    # Check each specified capability in the passed in capability object\n    if capability.roots is not None:\n        if client_caps.roots is None:\n            return False\n        if capability.roots.listChanged and not client_caps.roots.listChanged:\n            return False\n\n    if capability.sampling is not None:\n        if client_caps.sampling is None:\n            return False\n\n    if capability.experimental is not None:\n        if client_caps.experimental is None:\n            return False\n        # Check each experimental capability\n        for exp_key, exp_value in capability.experimental.items():\n            if (\n                exp_key not in client_caps.experimental\n                or client_caps.experimental[exp_key] != exp_value\n            ):\n                return False\n\n    return True\n</code></pre>"},{"location":"api/#mcp.ServerSession.send_log_message","title":"send_log_message  <code>async</code>","text":"<pre><code>send_log_message(\n    level: LoggingLevel,\n    data: Any,\n    logger: str | None = None,\n    related_request_id: RequestId | None = None,\n) -&gt; None\n</code></pre> <p>Send a log message notification.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def send_log_message(\n    self,\n    level: types.LoggingLevel,\n    data: Any,\n    logger: str | None = None,\n    related_request_id: types.RequestId | None = None,\n) -&gt; None:\n    \"\"\"Send a log message notification.\"\"\"\n    await self.send_notification(\n        types.ServerNotification(\n            types.LoggingMessageNotification(\n                method=\"notifications/message\",\n                params=types.LoggingMessageNotificationParams(\n                    level=level,\n                    data=data,\n                    logger=logger,\n                ),\n            )\n        ),\n        related_request_id,\n    )\n</code></pre>"},{"location":"api/#mcp.ServerSession.send_resource_updated","title":"send_resource_updated  <code>async</code>","text":"<pre><code>send_resource_updated(uri: AnyUrl) -&gt; None\n</code></pre> <p>Send a resource updated notification.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def send_resource_updated(self, uri: AnyUrl) -&gt; None:\n    \"\"\"Send a resource updated notification.\"\"\"\n    await self.send_notification(\n        types.ServerNotification(\n            types.ResourceUpdatedNotification(\n                method=\"notifications/resources/updated\",\n                params=types.ResourceUpdatedNotificationParams(uri=uri),\n            )\n        )\n    )\n</code></pre>"},{"location":"api/#mcp.ServerSession.create_message","title":"create_message  <code>async</code>","text":"<pre><code>create_message(\n    messages: list[SamplingMessage],\n    *,\n    max_tokens: int,\n    system_prompt: str | None = None,\n    include_context: IncludeContext | None = None,\n    temperature: float | None = None,\n    stop_sequences: list[str] | None = None,\n    metadata: dict[str, Any] | None = None,\n    model_preferences: ModelPreferences | None = None,\n    related_request_id: RequestId | None = None\n) -&gt; CreateMessageResult\n</code></pre> <p>Send a sampling/create_message request.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def create_message(\n    self,\n    messages: list[types.SamplingMessage],\n    *,\n    max_tokens: int,\n    system_prompt: str | None = None,\n    include_context: types.IncludeContext | None = None,\n    temperature: float | None = None,\n    stop_sequences: list[str] | None = None,\n    metadata: dict[str, Any] | None = None,\n    model_preferences: types.ModelPreferences | None = None,\n    related_request_id: types.RequestId | None = None,\n) -&gt; types.CreateMessageResult:\n    \"\"\"Send a sampling/create_message request.\"\"\"\n    return await self.send_request(\n        request=types.ServerRequest(\n            types.CreateMessageRequest(\n                method=\"sampling/createMessage\",\n                params=types.CreateMessageRequestParams(\n                    messages=messages,\n                    systemPrompt=system_prompt,\n                    includeContext=include_context,\n                    temperature=temperature,\n                    maxTokens=max_tokens,\n                    stopSequences=stop_sequences,\n                    metadata=metadata,\n                    modelPreferences=model_preferences,\n                ),\n            )\n        ),\n        result_type=types.CreateMessageResult,\n        metadata=ServerMessageMetadata(\n            related_request_id=related_request_id,\n        ),\n    )\n</code></pre>"},{"location":"api/#mcp.ServerSession.list_roots","title":"list_roots  <code>async</code>","text":"<pre><code>list_roots() -&gt; ListRootsResult\n</code></pre> <p>Send a roots/list request.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def list_roots(self) -&gt; types.ListRootsResult:\n    \"\"\"Send a roots/list request.\"\"\"\n    return await self.send_request(\n        types.ServerRequest(\n            types.ListRootsRequest(\n                method=\"roots/list\",\n            )\n        ),\n        types.ListRootsResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ServerSession.send_ping","title":"send_ping  <code>async</code>","text":"<pre><code>send_ping() -&gt; EmptyResult\n</code></pre> <p>Send a ping request.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def send_ping(self) -&gt; types.EmptyResult:\n    \"\"\"Send a ping request.\"\"\"\n    return await self.send_request(\n        types.ServerRequest(\n            types.PingRequest(\n                method=\"ping\",\n            )\n        ),\n        types.EmptyResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ServerSession.send_progress_notification","title":"send_progress_notification  <code>async</code>","text":"<pre><code>send_progress_notification(\n    progress_token: str | int,\n    progress: float,\n    total: float | None = None,\n    message: str | None = None,\n    related_request_id: str | None = None,\n) -&gt; None\n</code></pre> <p>Send a progress notification.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def send_progress_notification(\n    self,\n    progress_token: str | int,\n    progress: float,\n    total: float | None = None,\n    message: str | None = None,\n    related_request_id: str | None = None,\n) -&gt; None:\n    \"\"\"Send a progress notification.\"\"\"\n    await self.send_notification(\n        types.ServerNotification(\n            types.ProgressNotification(\n                method=\"notifications/progress\",\n                params=types.ProgressNotificationParams(\n                    progressToken=progress_token,\n                    progress=progress,\n                    total=total,\n                    message=message,\n                ),\n            )\n        ),\n        related_request_id,\n    )\n</code></pre>"},{"location":"api/#mcp.ServerSession.send_resource_list_changed","title":"send_resource_list_changed  <code>async</code>","text":"<pre><code>send_resource_list_changed() -&gt; None\n</code></pre> <p>Send a resource list changed notification.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def send_resource_list_changed(self) -&gt; None:\n    \"\"\"Send a resource list changed notification.\"\"\"\n    await self.send_notification(\n        types.ServerNotification(\n            types.ResourceListChangedNotification(\n                method=\"notifications/resources/list_changed\",\n            )\n        )\n    )\n</code></pre>"},{"location":"api/#mcp.ServerSession.send_tool_list_changed","title":"send_tool_list_changed  <code>async</code>","text":"<pre><code>send_tool_list_changed() -&gt; None\n</code></pre> <p>Send a tool list changed notification.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def send_tool_list_changed(self) -&gt; None:\n    \"\"\"Send a tool list changed notification.\"\"\"\n    await self.send_notification(\n        types.ServerNotification(\n            types.ToolListChangedNotification(\n                method=\"notifications/tools/list_changed\",\n            )\n        )\n    )\n</code></pre>"},{"location":"api/#mcp.ServerSession.send_prompt_list_changed","title":"send_prompt_list_changed  <code>async</code>","text":"<pre><code>send_prompt_list_changed() -&gt; None\n</code></pre> <p>Send a prompt list changed notification.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def send_prompt_list_changed(self) -&gt; None:\n    \"\"\"Send a prompt list changed notification.\"\"\"\n    await self.send_notification(\n        types.ServerNotification(\n            types.PromptListChangedNotification(\n                method=\"notifications/prompts/list_changed\",\n            )\n        )\n    )\n</code></pre>"},{"location":"api/#mcp.stdio_server","title":"stdio_server  <code>async</code>","text":"<pre><code>stdio_server(\n    stdin: AsyncFile[str] | None = None,\n    stdout: AsyncFile[str] | None = None,\n)\n</code></pre> <p>Server transport for stdio: this communicates with an MCP client by reading from the current process' stdin and writing to stdout.</p> Source code in <code>src/mcp/server/stdio.py</code> <pre><code>@asynccontextmanager\nasync def stdio_server(\n    stdin: anyio.AsyncFile[str] | None = None,\n    stdout: anyio.AsyncFile[str] | None = None,\n):\n    \"\"\"\n    Server transport for stdio: this communicates with an MCP client by reading\n    from the current process' stdin and writing to stdout.\n    \"\"\"\n    # Purposely not using context managers for these, as we don't want to close\n    # standard process handles. Encoding of stdin/stdout as text streams on\n    # python is platform-dependent (Windows is particularly problematic), so we\n    # re-wrap the underlying binary stream to ensure UTF-8.\n    if not stdin:\n        stdin = anyio.wrap_file(TextIOWrapper(sys.stdin.buffer, encoding=\"utf-8\"))\n    if not stdout:\n        stdout = anyio.wrap_file(TextIOWrapper(sys.stdout.buffer, encoding=\"utf-8\"))\n\n    read_stream: MemoryObjectReceiveStream[SessionMessage | Exception]\n    read_stream_writer: MemoryObjectSendStream[SessionMessage | Exception]\n\n    write_stream: MemoryObjectSendStream[SessionMessage]\n    write_stream_reader: MemoryObjectReceiveStream[SessionMessage]\n\n    read_stream_writer, read_stream = anyio.create_memory_object_stream(0)\n    write_stream, write_stream_reader = anyio.create_memory_object_stream(0)\n\n    async def stdin_reader():\n        try:\n            async with read_stream_writer:\n                async for line in stdin:\n                    try:\n                        message = types.JSONRPCMessage.model_validate_json(line)\n                    except Exception as exc:\n                        await read_stream_writer.send(exc)\n                        continue\n\n                    session_message = SessionMessage(message)\n                    await read_stream_writer.send(session_message)\n        except anyio.ClosedResourceError:\n            await anyio.lowlevel.checkpoint()\n\n    async def stdout_writer():\n        try:\n            async with write_stream_reader:\n                async for session_message in write_stream_reader:\n                    json = session_message.message.model_dump_json(\n                        by_alias=True, exclude_none=True\n                    )\n                    await stdout.write(json + \"\\n\")\n                    await stdout.flush()\n        except anyio.ClosedResourceError:\n            await anyio.lowlevel.checkpoint()\n\n    async with anyio.create_task_group() as tg:\n        tg.start_soon(stdin_reader)\n        tg.start_soon(stdout_writer)\n        yield read_stream, write_stream\n</code></pre>"},{"location":"api/#mcp.McpError","title":"McpError","text":"<p>               Bases: <code>Exception</code></p> <p>Exception type raised when an error arrives over an MCP connection.</p> Source code in <code>src/mcp/shared/exceptions.py</code> <pre><code>class McpError(Exception):\n    \"\"\"\n    Exception type raised when an error arrives over an MCP connection.\n    \"\"\"\n\n    error: ErrorData\n\n    def __init__(self, error: ErrorData):\n        \"\"\"Initialize McpError.\"\"\"\n        super().__init__(error.message)\n        self.error = error\n</code></pre>"},{"location":"api/#mcp.McpError.__init__","title":"__init__","text":"<pre><code>__init__(error: ErrorData)\n</code></pre> <p>Initialize McpError.</p> Source code in <code>src/mcp/shared/exceptions.py</code> <pre><code>def __init__(self, error: ErrorData):\n    \"\"\"Initialize McpError.\"\"\"\n    super().__init__(error.message)\n    self.error = error\n</code></pre>"},{"location":"api/#mcp.CallToolRequest","title":"CallToolRequest","text":"<p>               Bases: <code>Request[CallToolRequestParams, Literal['tools/call']]</code></p> <p>Used by the client to invoke a tool provided by the server.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class CallToolRequest(Request[CallToolRequestParams, Literal[\"tools/call\"]]):\n    \"\"\"Used by the client to invoke a tool provided by the server.\"\"\"\n\n    method: Literal[\"tools/call\"]\n    params: CallToolRequestParams\n</code></pre>"},{"location":"api/#mcp.ClientCapabilities","title":"ClientCapabilities","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capabilities a client may support.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ClientCapabilities(BaseModel):\n    \"\"\"Capabilities a client may support.\"\"\"\n\n    experimental: dict[str, dict[str, Any]] | None = None\n    \"\"\"Experimental, non-standard capabilities that the client supports.\"\"\"\n    sampling: SamplingCapability | None = None\n    \"\"\"Present if the client supports sampling from an LLM.\"\"\"\n    roots: RootsCapability | None = None\n    \"\"\"Present if the client supports listing roots.\"\"\"\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.ClientCapabilities.experimental","title":"experimental  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>experimental: dict[str, dict[str, Any]] | None = None\n</code></pre> <p>Experimental, non-standard capabilities that the client supports.</p>"},{"location":"api/#mcp.ClientCapabilities.sampling","title":"sampling  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sampling: SamplingCapability | None = None\n</code></pre> <p>Present if the client supports sampling from an LLM.</p>"},{"location":"api/#mcp.ClientCapabilities.roots","title":"roots  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>roots: RootsCapability | None = None\n</code></pre> <p>Present if the client supports listing roots.</p>"},{"location":"api/#mcp.CompleteRequest","title":"CompleteRequest","text":"<p>               Bases: <code>Request[CompleteRequestParams, Literal['completion/complete']]</code></p> <p>A request from the client to the server, to ask for completion options.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class CompleteRequest(Request[CompleteRequestParams, Literal[\"completion/complete\"]]):\n    \"\"\"A request from the client to the server, to ask for completion options.\"\"\"\n\n    method: Literal[\"completion/complete\"]\n    params: CompleteRequestParams\n</code></pre>"},{"location":"api/#mcp.CreateMessageRequest","title":"CreateMessageRequest","text":"<p>               Bases: <code>Request[CreateMessageRequestParams, Literal['sampling/createMessage']]</code></p> <p>A request from the server to sample an LLM via the client.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class CreateMessageRequest(\n    Request[CreateMessageRequestParams, Literal[\"sampling/createMessage\"]]\n):\n    \"\"\"A request from the server to sample an LLM via the client.\"\"\"\n\n    method: Literal[\"sampling/createMessage\"]\n    params: CreateMessageRequestParams\n</code></pre>"},{"location":"api/#mcp.CreateMessageResult","title":"CreateMessageResult","text":"<p>               Bases: <code>Result</code></p> <p>The client's response to a sampling/create_message request from the server.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class CreateMessageResult(Result):\n    \"\"\"The client's response to a sampling/create_message request from the server.\"\"\"\n\n    role: Role\n    content: TextContent | ImageContent\n    model: str\n    \"\"\"The name of the model that generated the message.\"\"\"\n    stopReason: StopReason | None = None\n    \"\"\"The reason why sampling stopped, if known.\"\"\"\n</code></pre>"},{"location":"api/#mcp.CreateMessageResult.model","title":"model  <code>instance-attribute</code>","text":"<pre><code>model: str\n</code></pre> <p>The name of the model that generated the message.</p>"},{"location":"api/#mcp.CreateMessageResult.stopReason","title":"stopReason  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stopReason: StopReason | None = None\n</code></pre> <p>The reason why sampling stopped, if known.</p>"},{"location":"api/#mcp.ErrorData","title":"ErrorData","text":"<p>               Bases: <code>BaseModel</code></p> <p>Error information for JSON-RPC error responses.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ErrorData(BaseModel):\n    \"\"\"Error information for JSON-RPC error responses.\"\"\"\n\n    code: int\n    \"\"\"The error type that occurred.\"\"\"\n\n    message: str\n    \"\"\"\n    A short description of the error. The message SHOULD be limited to a concise single\n    sentence.\n    \"\"\"\n\n    data: Any | None = None\n    \"\"\"\n    Additional information about the error. The value of this member is defined by the\n    sender (e.g. detailed error information, nested errors etc.).\n    \"\"\"\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.ErrorData.code","title":"code  <code>instance-attribute</code>","text":"<pre><code>code: int\n</code></pre> <p>The error type that occurred.</p>"},{"location":"api/#mcp.ErrorData.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message: str\n</code></pre> <p>A short description of the error. The message SHOULD be limited to a concise single sentence.</p>"},{"location":"api/#mcp.ErrorData.data","title":"data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data: Any | None = None\n</code></pre> <p>Additional information about the error. The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.).</p>"},{"location":"api/#mcp.GetPromptRequest","title":"GetPromptRequest","text":"<p>               Bases: <code>Request[GetPromptRequestParams, Literal['prompts/get']]</code></p> <p>Used by the client to get a prompt provided by the server.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class GetPromptRequest(Request[GetPromptRequestParams, Literal[\"prompts/get\"]]):\n    \"\"\"Used by the client to get a prompt provided by the server.\"\"\"\n\n    method: Literal[\"prompts/get\"]\n    params: GetPromptRequestParams\n</code></pre>"},{"location":"api/#mcp.GetPromptResult","title":"GetPromptResult","text":"<p>               Bases: <code>Result</code></p> <p>The server's response to a prompts/get request from the client.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class GetPromptResult(Result):\n    \"\"\"The server's response to a prompts/get request from the client.\"\"\"\n\n    description: str | None = None\n    \"\"\"An optional description for the prompt.\"\"\"\n    messages: list[PromptMessage]\n</code></pre>"},{"location":"api/#mcp.GetPromptResult.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str | None = None\n</code></pre> <p>An optional description for the prompt.</p>"},{"location":"api/#mcp.Implementation","title":"Implementation","text":"<p>               Bases: <code>BaseModel</code></p> <p>Describes the name and version of an MCP implementation.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class Implementation(BaseModel):\n    \"\"\"Describes the name and version of an MCP implementation.\"\"\"\n\n    name: str\n    version: str\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.InitializedNotification","title":"InitializedNotification","text":"<p>               Bases: <code>Notification[NotificationParams | None, Literal['notifications/initialized']]</code></p> <p>This notification is sent from the client to the server after initialization has finished.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class InitializedNotification(\n    Notification[NotificationParams | None, Literal[\"notifications/initialized\"]]\n):\n    \"\"\"\n    This notification is sent from the client to the server after initialization has\n    finished.\n    \"\"\"\n\n    method: Literal[\"notifications/initialized\"]\n    params: NotificationParams | None = None\n</code></pre>"},{"location":"api/#mcp.InitializeRequest","title":"InitializeRequest","text":"<p>               Bases: <code>Request[InitializeRequestParams, Literal['initialize']]</code></p> <p>This request is sent from the client to the server when it first connects, asking it to begin initialization.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class InitializeRequest(Request[InitializeRequestParams, Literal[\"initialize\"]]):\n    \"\"\"\n    This request is sent from the client to the server when it first connects, asking it\n    to begin initialization.\n    \"\"\"\n\n    method: Literal[\"initialize\"]\n    params: InitializeRequestParams\n</code></pre>"},{"location":"api/#mcp.InitializeResult","title":"InitializeResult","text":"<p>               Bases: <code>Result</code></p> <p>After receiving an initialize request from the client, the server sends this.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class InitializeResult(Result):\n    \"\"\"After receiving an initialize request from the client, the server sends this.\"\"\"\n\n    protocolVersion: str | int\n    \"\"\"The version of the Model Context Protocol that the server wants to use.\"\"\"\n    capabilities: ServerCapabilities\n    serverInfo: Implementation\n    instructions: str | None = None\n    \"\"\"Instructions describing how to use the server and its features.\"\"\"\n</code></pre>"},{"location":"api/#mcp.InitializeResult.protocolVersion","title":"protocolVersion  <code>instance-attribute</code>","text":"<pre><code>protocolVersion: str | int\n</code></pre> <p>The version of the Model Context Protocol that the server wants to use.</p>"},{"location":"api/#mcp.InitializeResult.instructions","title":"instructions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>instructions: str | None = None\n</code></pre> <p>Instructions describing how to use the server and its features.</p>"},{"location":"api/#mcp.JSONRPCError","title":"JSONRPCError","text":"<p>               Bases: <code>BaseModel</code></p> <p>A response to a request that indicates an error occurred.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class JSONRPCError(BaseModel):\n    \"\"\"A response to a request that indicates an error occurred.\"\"\"\n\n    jsonrpc: Literal[\"2.0\"]\n    id: str | int\n    error: ErrorData\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.JSONRPCRequest","title":"JSONRPCRequest","text":"<p>               Bases: <code>Request[dict[str, Any] | None, str]</code></p> <p>A request that expects a response.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class JSONRPCRequest(Request[dict[str, Any] | None, str]):\n    \"\"\"A request that expects a response.\"\"\"\n\n    jsonrpc: Literal[\"2.0\"]\n    id: RequestId\n    method: str\n    params: dict[str, Any] | None = None\n</code></pre>"},{"location":"api/#mcp.JSONRPCResponse","title":"JSONRPCResponse","text":"<p>               Bases: <code>BaseModel</code></p> <p>A successful (non-error) response to a request.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class JSONRPCResponse(BaseModel):\n    \"\"\"A successful (non-error) response to a request.\"\"\"\n\n    jsonrpc: Literal[\"2.0\"]\n    id: RequestId\n    result: dict[str, Any]\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.ListPromptsRequest","title":"ListPromptsRequest","text":"<p>               Bases: <code>PaginatedRequest[RequestParams | None, Literal['prompts/list']]</code></p> <p>Sent from the client to request a list of prompts and prompt templates.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ListPromptsRequest(\n    PaginatedRequest[RequestParams | None, Literal[\"prompts/list\"]]\n):\n    \"\"\"Sent from the client to request a list of prompts and prompt templates.\"\"\"\n\n    method: Literal[\"prompts/list\"]\n    params: RequestParams | None = None\n</code></pre>"},{"location":"api/#mcp.ListPromptsResult","title":"ListPromptsResult","text":"<p>               Bases: <code>PaginatedResult</code></p> <p>The server's response to a prompts/list request from the client.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ListPromptsResult(PaginatedResult):\n    \"\"\"The server's response to a prompts/list request from the client.\"\"\"\n\n    prompts: list[Prompt]\n</code></pre>"},{"location":"api/#mcp.ListResourcesRequest","title":"ListResourcesRequest","text":"<p>               Bases: <code>PaginatedRequest[RequestParams | None, Literal['resources/list']]</code></p> <p>Sent from the client to request a list of resources the server has.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ListResourcesRequest(\n    PaginatedRequest[RequestParams | None, Literal[\"resources/list\"]]\n):\n    \"\"\"Sent from the client to request a list of resources the server has.\"\"\"\n\n    method: Literal[\"resources/list\"]\n    params: RequestParams | None = None\n</code></pre>"},{"location":"api/#mcp.ListResourcesResult","title":"ListResourcesResult","text":"<p>               Bases: <code>PaginatedResult</code></p> <p>The server's response to a resources/list request from the client.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ListResourcesResult(PaginatedResult):\n    \"\"\"The server's response to a resources/list request from the client.\"\"\"\n\n    resources: list[Resource]\n</code></pre>"},{"location":"api/#mcp.ListToolsResult","title":"ListToolsResult","text":"<p>               Bases: <code>PaginatedResult</code></p> <p>The server's response to a tools/list request from the client.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ListToolsResult(PaginatedResult):\n    \"\"\"The server's response to a tools/list request from the client.\"\"\"\n\n    tools: list[Tool]\n</code></pre>"},{"location":"api/#mcp.LoggingMessageNotification","title":"LoggingMessageNotification","text":"<p>               Bases: <code>Notification[LoggingMessageNotificationParams, Literal['notifications/message']]</code></p> <p>Notification of a log message passed from server to client.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class LoggingMessageNotification(\n    Notification[LoggingMessageNotificationParams, Literal[\"notifications/message\"]]\n):\n    \"\"\"Notification of a log message passed from server to client.\"\"\"\n\n    method: Literal[\"notifications/message\"]\n    params: LoggingMessageNotificationParams\n</code></pre>"},{"location":"api/#mcp.Notification","title":"Notification","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[NotificationParamsT, MethodT]</code></p> <p>Base class for JSON-RPC notifications.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class Notification(BaseModel, Generic[NotificationParamsT, MethodT]):\n    \"\"\"Base class for JSON-RPC notifications.\"\"\"\n\n    method: MethodT\n    params: NotificationParamsT\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.PingRequest","title":"PingRequest","text":"<p>               Bases: <code>Request[RequestParams | None, Literal['ping']]</code></p> <p>A ping, issued by either the server or the client, to check that the other party is still alive.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class PingRequest(Request[RequestParams | None, Literal[\"ping\"]]):\n    \"\"\"\n    A ping, issued by either the server or the client, to check that the other party is\n    still alive.\n    \"\"\"\n\n    method: Literal[\"ping\"]\n    params: RequestParams | None = None\n</code></pre>"},{"location":"api/#mcp.ProgressNotification","title":"ProgressNotification","text":"<p>               Bases: <code>Notification[ProgressNotificationParams, Literal['notifications/progress']]</code></p> <p>An out-of-band notification used to inform the receiver of a progress update for a long-running request.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ProgressNotification(\n    Notification[ProgressNotificationParams, Literal[\"notifications/progress\"]]\n):\n    \"\"\"\n    An out-of-band notification used to inform the receiver of a progress update for a\n    long-running request.\n    \"\"\"\n\n    method: Literal[\"notifications/progress\"]\n    params: ProgressNotificationParams\n</code></pre>"},{"location":"api/#mcp.PromptsCapability","title":"PromptsCapability","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capability for prompts operations.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class PromptsCapability(BaseModel):\n    \"\"\"Capability for prompts operations.\"\"\"\n\n    listChanged: bool | None = None\n    \"\"\"Whether this server supports notifications for changes to the prompt list.\"\"\"\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.PromptsCapability.listChanged","title":"listChanged  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>listChanged: bool | None = None\n</code></pre> <p>Whether this server supports notifications for changes to the prompt list.</p>"},{"location":"api/#mcp.ReadResourceRequest","title":"ReadResourceRequest","text":"<p>               Bases: <code>Request[ReadResourceRequestParams, Literal['resources/read']]</code></p> <p>Sent from the client to the server, to read a specific resource URI.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ReadResourceRequest(\n    Request[ReadResourceRequestParams, Literal[\"resources/read\"]]\n):\n    \"\"\"Sent from the client to the server, to read a specific resource URI.\"\"\"\n\n    method: Literal[\"resources/read\"]\n    params: ReadResourceRequestParams\n</code></pre>"},{"location":"api/#mcp.ReadResourceResult","title":"ReadResourceResult","text":"<p>               Bases: <code>Result</code></p> <p>The server's response to a resources/read request from the client.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ReadResourceResult(Result):\n    \"\"\"The server's response to a resources/read request from the client.\"\"\"\n\n    contents: list[TextResourceContents | BlobResourceContents]\n</code></pre>"},{"location":"api/#mcp.Resource","title":"Resource","text":"<p>               Bases: <code>BaseModel</code></p> <p>A known resource that the server is capable of reading.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class Resource(BaseModel):\n    \"\"\"A known resource that the server is capable of reading.\"\"\"\n\n    uri: Annotated[AnyUrl, UrlConstraints(host_required=False)]\n    \"\"\"The URI of this resource.\"\"\"\n    name: str\n    \"\"\"A human-readable name for this resource.\"\"\"\n    description: str | None = None\n    \"\"\"A description of what this resource represents.\"\"\"\n    mimeType: str | None = None\n    \"\"\"The MIME type of this resource, if known.\"\"\"\n    size: int | None = None\n    \"\"\"\n    The size of the raw resource content, in bytes (i.e., before base64 encoding\n    or any tokenization), if known.\n\n    This can be used by Hosts to display file sizes and estimate context window usage.\n    \"\"\"\n    annotations: Annotations | None = None\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.Resource.uri","title":"uri  <code>instance-attribute</code>","text":"<pre><code>uri: Annotated[AnyUrl, UrlConstraints(host_required=False)]\n</code></pre> <p>The URI of this resource.</p>"},{"location":"api/#mcp.Resource.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>A human-readable name for this resource.</p>"},{"location":"api/#mcp.Resource.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str | None = None\n</code></pre> <p>A description of what this resource represents.</p>"},{"location":"api/#mcp.Resource.mimeType","title":"mimeType  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mimeType: str | None = None\n</code></pre> <p>The MIME type of this resource, if known.</p>"},{"location":"api/#mcp.Resource.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>size: int | None = None\n</code></pre> <p>The size of the raw resource content, in bytes (i.e., before base64 encoding or any tokenization), if known.</p> <p>This can be used by Hosts to display file sizes and estimate context window usage.</p>"},{"location":"api/#mcp.ResourcesCapability","title":"ResourcesCapability","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capability for resources operations.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ResourcesCapability(BaseModel):\n    \"\"\"Capability for resources operations.\"\"\"\n\n    subscribe: bool | None = None\n    \"\"\"Whether this server supports subscribing to resource updates.\"\"\"\n    listChanged: bool | None = None\n    \"\"\"Whether this server supports notifications for changes to the resource list.\"\"\"\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.ResourcesCapability.subscribe","title":"subscribe  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>subscribe: bool | None = None\n</code></pre> <p>Whether this server supports subscribing to resource updates.</p>"},{"location":"api/#mcp.ResourcesCapability.listChanged","title":"listChanged  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>listChanged: bool | None = None\n</code></pre> <p>Whether this server supports notifications for changes to the resource list.</p>"},{"location":"api/#mcp.ResourceUpdatedNotification","title":"ResourceUpdatedNotification","text":"<p>               Bases: <code>Notification[ResourceUpdatedNotificationParams, Literal['notifications/resources/updated']]</code></p> <p>A notification from the server to the client, informing it that a resource has changed and may need to be read again.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ResourceUpdatedNotification(\n    Notification[\n        ResourceUpdatedNotificationParams, Literal[\"notifications/resources/updated\"]\n    ]\n):\n    \"\"\"\n    A notification from the server to the client, informing it that a resource has\n    changed and may need to be read again.\n    \"\"\"\n\n    method: Literal[\"notifications/resources/updated\"]\n    params: ResourceUpdatedNotificationParams\n</code></pre>"},{"location":"api/#mcp.RootsCapability","title":"RootsCapability","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capability for root operations.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class RootsCapability(BaseModel):\n    \"\"\"Capability for root operations.\"\"\"\n\n    listChanged: bool | None = None\n    \"\"\"Whether the client supports notifications for changes to the roots list.\"\"\"\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.RootsCapability.listChanged","title":"listChanged  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>listChanged: bool | None = None\n</code></pre> <p>Whether the client supports notifications for changes to the roots list.</p>"},{"location":"api/#mcp.SamplingMessage","title":"SamplingMessage","text":"<p>               Bases: <code>BaseModel</code></p> <p>Describes a message issued to or received from an LLM API.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class SamplingMessage(BaseModel):\n    \"\"\"Describes a message issued to or received from an LLM API.\"\"\"\n\n    role: Role\n    content: TextContent | ImageContent\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.ServerCapabilities","title":"ServerCapabilities","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capabilities that a server may support.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ServerCapabilities(BaseModel):\n    \"\"\"Capabilities that a server may support.\"\"\"\n\n    experimental: dict[str, dict[str, Any]] | None = None\n    \"\"\"Experimental, non-standard capabilities that the server supports.\"\"\"\n    logging: LoggingCapability | None = None\n    \"\"\"Present if the server supports sending log messages to the client.\"\"\"\n    prompts: PromptsCapability | None = None\n    \"\"\"Present if the server offers any prompt templates.\"\"\"\n    resources: ResourcesCapability | None = None\n    \"\"\"Present if the server offers any resources to read.\"\"\"\n    tools: ToolsCapability | None = None\n    \"\"\"Present if the server offers any tools to call.\"\"\"\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.ServerCapabilities.experimental","title":"experimental  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>experimental: dict[str, dict[str, Any]] | None = None\n</code></pre> <p>Experimental, non-standard capabilities that the server supports.</p>"},{"location":"api/#mcp.ServerCapabilities.logging","title":"logging  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>logging: LoggingCapability | None = None\n</code></pre> <p>Present if the server supports sending log messages to the client.</p>"},{"location":"api/#mcp.ServerCapabilities.prompts","title":"prompts  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prompts: PromptsCapability | None = None\n</code></pre> <p>Present if the server offers any prompt templates.</p>"},{"location":"api/#mcp.ServerCapabilities.resources","title":"resources  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>resources: ResourcesCapability | None = None\n</code></pre> <p>Present if the server offers any resources to read.</p>"},{"location":"api/#mcp.ServerCapabilities.tools","title":"tools  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tools: ToolsCapability | None = None\n</code></pre> <p>Present if the server offers any tools to call.</p>"},{"location":"api/#mcp.SetLevelRequest","title":"SetLevelRequest","text":"<p>               Bases: <code>Request[SetLevelRequestParams, Literal['logging/setLevel']]</code></p> <p>A request from the client to the server, to enable or adjust logging.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class SetLevelRequest(Request[SetLevelRequestParams, Literal[\"logging/setLevel\"]]):\n    \"\"\"A request from the client to the server, to enable or adjust logging.\"\"\"\n\n    method: Literal[\"logging/setLevel\"]\n    params: SetLevelRequestParams\n</code></pre>"},{"location":"api/#mcp.SubscribeRequest","title":"SubscribeRequest","text":"<p>               Bases: <code>Request[SubscribeRequestParams, Literal['resources/subscribe']]</code></p> <p>Sent from the client to request resources/updated notifications from the server whenever a particular resource changes.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class SubscribeRequest(Request[SubscribeRequestParams, Literal[\"resources/subscribe\"]]):\n    \"\"\"\n    Sent from the client to request resources/updated notifications from the server\n    whenever a particular resource changes.\n    \"\"\"\n\n    method: Literal[\"resources/subscribe\"]\n    params: SubscribeRequestParams\n</code></pre>"},{"location":"api/#mcp.Tool","title":"Tool","text":"<p>               Bases: <code>BaseModel</code></p> <p>Definition for a tool the client can call.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class Tool(BaseModel):\n    \"\"\"Definition for a tool the client can call.\"\"\"\n\n    name: str\n    \"\"\"The name of the tool.\"\"\"\n    description: str | None = None\n    \"\"\"A human-readable description of the tool.\"\"\"\n    inputSchema: dict[str, Any]\n    \"\"\"A JSON Schema object defining the expected parameters for the tool.\"\"\"\n    annotations: ToolAnnotations | None = None\n    \"\"\"Optional additional tool information.\"\"\"\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.Tool.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the tool.</p>"},{"location":"api/#mcp.Tool.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str | None = None\n</code></pre> <p>A human-readable description of the tool.</p>"},{"location":"api/#mcp.Tool.inputSchema","title":"inputSchema  <code>instance-attribute</code>","text":"<pre><code>inputSchema: dict[str, Any]\n</code></pre> <p>A JSON Schema object defining the expected parameters for the tool.</p>"},{"location":"api/#mcp.Tool.annotations","title":"annotations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>annotations: ToolAnnotations | None = None\n</code></pre> <p>Optional additional tool information.</p>"},{"location":"api/#mcp.ToolsCapability","title":"ToolsCapability","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capability for tools operations.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ToolsCapability(BaseModel):\n    \"\"\"Capability for tools operations.\"\"\"\n\n    listChanged: bool | None = None\n    \"\"\"Whether this server supports notifications for changes to the tool list.\"\"\"\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.ToolsCapability.listChanged","title":"listChanged  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>listChanged: bool | None = None\n</code></pre> <p>Whether this server supports notifications for changes to the tool list.</p>"},{"location":"api/#mcp.UnsubscribeRequest","title":"UnsubscribeRequest","text":"<p>               Bases: <code>Request[UnsubscribeRequestParams, Literal['resources/unsubscribe']]</code></p> <p>Sent from the client to request cancellation of resources/updated notifications from the server.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class UnsubscribeRequest(\n    Request[UnsubscribeRequestParams, Literal[\"resources/unsubscribe\"]]\n):\n    \"\"\"\n    Sent from the client to request cancellation of resources/updated notifications from\n    the server.\n    \"\"\"\n\n    method: Literal[\"resources/unsubscribe\"]\n    params: UnsubscribeRequestParams\n</code></pre>"},{"location":"attack-prevention/","title":"Attack Prevention","text":"<p>ETDI provides robust protection against advanced AI security threats, including tool poisoning, rug poisoning, and unauthorized tool access. This page summarizes the core attack prevention strategies and how to implement them.</p>"},{"location":"attack-prevention/#tool-poisoning-prevention","title":"Tool Poisoning Prevention","text":"<p>Tool poisoning occurs when a malicious actor introduces or replaces a tool with a compromised version. ETDI prevents this via:</p> <ul> <li>Cryptographic Signatures: All tools are signed and verified at registration and invocation. See Tool Poisoning Demo for details.</li> <li>Behavioral Verification: Tools are monitored for anomalous behavior and policy violations.</li> <li>Approval Workflow: Users must explicitly approve new or changed tools before use.</li> </ul>"},{"location":"attack-prevention/#example-secure-tool-registration","title":"Example: Secure Tool Registration","text":"<pre><code>@server.tool(\"secure_file_read\", require_signature=True)\nasync def secure_file_read(path: str) -&gt; str:\n    # Implementation with cryptographic verification\n    ...\n</code></pre>"},{"location":"attack-prevention/#rug-poisoning-protection","title":"Rug Poisoning Protection","text":"<p>Rug poisoning (\"rug pull\") is when a tool is swapped or modified after initial approval. ETDI detects and blocks this via:</p> <ul> <li>Immutable Versioning: Every tool version is cryptographically hashed and tracked.</li> <li>Change Detection: Any change to code, permissions, or metadata triggers reapproval.</li> <li>Audit Trails: All tool changes and approvals are logged for forensics.</li> </ul> <p>Details on how ETDI mitigates this can be found in Rug Poisoning Protection.</p>"},{"location":"attack-prevention/#example-versioned-tool-approval","title":"Example: Versioned Tool Approval","text":"<pre><code># User approves tool version 1.0\nawait client.approve_tool(tool_id, version=\"1.0\")\n\n# If the tool changes (hash mismatch), approval is revoked until reapproved by the user.\n</code></pre>"},{"location":"attack-prevention/#call-stack-security","title":"Call Stack Security","text":"<p>Call stack security is crucial for preventing privilege escalation and unauthorized tool chaining, ensuring that a sequence of tool calls doesn't lead to unintended capabilities or data access.</p> <p>ETDI implements call stack security through several mechanisms:</p> <ul> <li> <p>Maximum Call Depth: Defines how many levels deep a tool invocation chain can go. This prevents runaway recursive calls or overly complex interactions that might obscure malicious activity or lead to denial-of-service.     <pre><code># Part of SecurityPolicy or individual tool definition\n# server = SecureServer(security_policy=SecurityPolicy(max_call_depth=5))\n@server.tool(\"my_tool\", etdi_max_call_depth=3)\nasync def my_tool_impl(): ...\n</code></pre></p> </li> <li> <p>Allowed/Blocked Callees: Tool definitions can specify which other tools they are explicitly allowed to call, or which ones they are explicitly forbidden from calling. This creates a more predictable and constrained interaction graph.     <pre><code># Part of SecurityPolicy or individual tool definition\n# policy = SecurityPolicy(allowed_callees={\"tool_a\": [\"tool_b\"]})\n@server.tool(\"tool_a\", etdi_allowed_callees=[\"tool_b\", \"tool_c\"])\nasync def tool_a_impl(): ...\n\n@server.tool(\"sensitive_tool\", etdi_blocked_callees=[\"network_tool\", \"external_api_tool\"])\nasync def sensitive_tool_impl(): ...\n</code></pre></p> </li> <li> <p>Caller/Callee Authorization: Beyond just allowed/blocked lists, ETDI can enforce mutual authorization. This means not only must <code>tool_A</code> be allowed to call <code>tool_B</code>, but <code>tool_B</code> must also be configured to accept calls from <code>tool_A</code>. This is typically managed through permission and scope checks tied to the identities of the tools themselves (if they have their own service identities) or the user context propagating the call.</p> </li> <li> <p>Verification: The ETDI client and/or server-side middleware inspects the call stack at each invocation. If a call violates any of these constraints (e.g., exceeds max depth, calls a blocked tool, or lacks authorization), the invocation is rejected before the tool code executes.</p> </li> </ul> <p>These features collectively ensure that tool interactions are confined to well-defined boundaries, significantly reducing the attack surface.</p> <p>Refer to example scripts like <code>protocol_call_stack_example.py</code> and <code>caller_callee_authorization_example.py</code> in the Examples &amp; Demos section for practical implementations.</p>"},{"location":"attack-prevention/#call-chain-validation-legacy","title":"Call Chain Validation (Legacy)","text":"<p>This section is an older description and is superseded by the more detailed \"Call Stack Security\" section above. It is kept for historical context but the principles are better elaborated above.</p> <ul> <li>Stack Constraints: Prevents privilege escalation by enforcing max call depth and allowed call chains.</li> <li>Caller/Callee Authorization: Only authorized tools can invoke each other.</li> </ul>"},{"location":"attack-prevention/#example-call-chain-policy-legacy","title":"Example: Call Chain Policy (Legacy)","text":"<pre><code>from mcp.etdi.types import SecurityPolicy\n\npolicy = SecurityPolicy(\n    max_call_depth=5,\n    allowed_callers={\"tool_a\": [\"tool_b\", \"tool_c\"]}\n)\nserver = SecureServer(security_policy=policy)\n</code></pre>"},{"location":"attack-prevention/#real-world-attack-scenarios","title":"Real-World Attack Scenarios","text":"<ul> <li>Tool Poisoning Demo: See the detailed Tool Poisoning Prevention page and its associated demo scripts in <code>examples/etdi/tool_poisoning_demo/</code>.</li> <li>Rug Poisoning Detection: The framework automatically detects and blocks unauthorized tool changes as detailed in Rug Poisoning Protection.</li> </ul>"},{"location":"attack-prevention/#best-practices","title":"Best Practices","text":"<ul> <li>Always require tool signatures in production.</li> <li>Regularly audit tool approval and change logs.</li> <li>Use strict call chain policies (max depth, allowed/blocked callees) for sensitive operations. </li> </ul>"},{"location":"getting-started/","title":"Getting Started with ETDI","text":"<p>This guide will help you set up the Enhanced Tool Definition Interface (ETDI) security framework and create your first secure AI tool server.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11 or higher</li> <li>Git</li> <li>A text editor or IDE</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#1-clone-the-repository","title":"1. Clone the Repository","text":"<pre><code>git clone https://github.com/python-sdk-etdi/python-sdk-etdi.git\ncd python-sdk-etdi\n</code></pre>"},{"location":"getting-started/#2-set-up-virtual-environment","title":"2. Set Up Virtual Environment","text":"<pre><code>python -m venv .venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\n</code></pre>"},{"location":"getting-started/#3-install-dependencies","title":"3. Install Dependencies","text":"<pre><code>pip install -e .\n</code></pre>"},{"location":"getting-started/#quick-start-example","title":"Quick Start Example","text":"<p>Create your first secure server:</p> <pre><code># secure_server_example.py\nimport asyncio\nfrom mcp.etdi import SecureServer, ToolProvider\nfrom mcp.etdi.types import SecurityLevel\n\nasync def main():\n    # Create secure server with high security\n    server = SecureServer(\n        name=\"my-secure-server\",\n        security_level=SecurityLevel.HIGH,\n        enable_tool_verification=True,\n        enable_behavior_monitoring=True\n    )\n\n    # Register a secure tool\n    @server.tool(\"get_weather\")\n    async def get_weather(location: str) -&gt; dict:\n        \"\"\"Get weather for a location with security verification.\"\"\"\n        # Tool implementation here\n        return {\"location\": location, \"temperature\": \"72\u00b0F\"}\n\n    # Start the server\n    await server.start()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"getting-started/#security-configuration","title":"Security Configuration","text":"<p>Configure security levels and policies:</p> <pre><code>from mcp.etdi.types import SecurityPolicy, SecurityLevel\n\npolicy = SecurityPolicy(\n    security_level=SecurityLevel.HIGH,\n    require_tool_signatures=True,\n    enable_behavior_monitoring=True,\n    enable_call_chain_validation=True,\n    max_call_depth=10,\n    audit_all_calls=True\n)\n\nserver = SecureServer(security_policy=policy)\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Authentication Setup: Configure OAuth and enterprise SSO</li> <li>Tool Poisoning Prevention: Protect against malicious tools</li> <li>Examples: Explore real-world examples and demos</li> </ul>"},{"location":"getting-started/#verification","title":"Verification","text":"<p>Test your setup:</p> <pre><code>python examples/etdi/verify_implementation.py\n</code></pre> <p>This script will verify that ETDI is properly installed and configured.</p>"},{"location":"security-features/","title":"ETDI Security Features","text":"<p>ETDI provides a rich set of security features designed to protect AI tool interactions at multiple levels. These features work together to ensure tool authenticity, enforce access control, monitor behavior, and provide comprehensive auditability.</p>"},{"location":"security-features/#1-authentication","title":"1. Authentication","text":"<p>Ensuring that only legitimate users, services, and tools can interact with the system.</p> <ul> <li>OAuth 2.0 Integration: ETDI seamlessly integrates with standard OAuth 2.0 providers (e.g., Auth0, Okta, Azure AD) for robust identity verification. This allows leveraging existing enterprise identity systems.<ul> <li>Clients and Servers use OAuth tokens to authenticate.</li> <li>Support for various flows (Client Credentials, Authorization Code, etc.) depending on the use case.</li> <li>See <code>examples/etdi/oauth_providers.py</code> in the project's example code for configurations.</li> </ul> </li> <li>Single Sign-On (SSO): Through OAuth/OIDC providers, ETDI can support enterprise SSO, simplifying user management.</li> <li>Token Verification: All API calls requiring authentication are protected. Tokens are cryptographically verified (signatures, expiration, issuer, audience) by both the ETDI client and the secure server middleware.</li> <li>Mutual TLS (mTLS): For service-to-service communication, mTLS can be employed for an additional layer of authentication, ensuring both client and server verify each other's identity using X.509 certificates.</li> </ul>"},{"location":"security-features/#2-authorization","title":"2. Authorization","text":"<p>Defining and enforcing what authenticated entities are allowed to do.</p> <ul> <li>Fine-Grained Permissions: Tools explicitly declare the permissions they require to operate (e.g., <code>file:read</code>, <code>database:user:update</code>, <code>api:external_service:call</code>).     <pre><code>@server.tool(\"secure_file_read\", permissions=[\"file:read\", \"audit:log\"])\nasync def secure_file_read(path: str) -&gt; str:\n    # ... implementation\n    pass\n</code></pre></li> <li>Scope-Based Access Control: OAuth scopes granted to clients are checked against the permissions required by tools. A tool invocation is only allowed if the client possesses all necessary scopes.</li> <li>Role-Based Access Control (RBAC): User roles, often managed by the OAuth provider, can be mapped to sets of permissions or scopes, simplifying authorization management.</li> <li>Caller/Callee Authorization: Specific to Call Stack Security, this ensures that a tool (caller) is authorized to invoke another tool (callee), and the callee is authorized to be invoked by the caller.</li> </ul>"},{"location":"security-features/#3-tool-integrity-verification","title":"3. Tool Integrity &amp; Verification","text":"<p>Ensuring tools are authentic, have not been tampered with, and their versions are managed.</p> <ul> <li>Cryptographic Signatures: Tool definitions can be cryptographically signed by their providers. ETDI clients verify these signatures to ensure the tool definition hasn't been altered since publication.</li> <li>Immutable Versioning: Each version of a tool has a unique identifier, and its definition (including code references or hashes) is immutable. This is key to Rug Poisoning Protection.</li> <li>Behavioral Verification &amp; Monitoring (Conceptual): While direct real-time behavioral blocking might be an advanced feature, ETDI supports robust audit logging. These logs can be fed into external security monitoring systems (like SIEMs) to detect anomalous behavior (e.g., resource access patterns, API call frequency) and trigger alerts or manual intervention. The core ETDI framework focuses on providing the necessary data for such systems.</li> <li>Approval Workflows: ETDI clients require explicit user approval for new tools or new versions of existing tools, especially if permissions change. This gives users control over which tools can operate on their behalf.</li> </ul>"},{"location":"security-features/#4-audit-logging","title":"4. Audit Logging","text":"<p>Comprehensive logging of all security-relevant events for monitoring, forensics, and compliance.</p> <ul> <li>Security Events Logged: <ul> <li>Tool discovery, verification success/failure.</li> <li>Tool approval and revocation.</li> <li>Tool invocation requests (with parameters, if configured).</li> <li>Authentication success/failure.</li> <li>Authorization success/failure (permission/scope checks).</li> <li>Detected security policy violations (e.g., call stack violations).</li> </ul> </li> <li>Standardized Log Format: Logs can be structured (e.g., JSON) for easy integration with SIEMs and log analysis platforms.</li> <li>Forensic Analysis: Detailed logs help in tracing the source and impact of any security incident.</li> </ul>"},{"location":"security-features/#configuration-examples","title":"Configuration Examples","text":"<p>Security features are typically configured when initializing the <code>SecureServer</code> or through specific decorators and policies:</p> <pre><code>from mcp.etdi import SecureServer\nfrom mcp.etdi.types import SecurityPolicy, SecurityLevel # OAuthConfig removed as it might not be directly used here\n# from mcp.etdi.auth import OAuthHandler # Assuming this exists for server-side setup\n\n# Example Security Policy\npolicy = SecurityPolicy(\n    security_level=SecurityLevel.HIGH,       # Or STRICT, ENHANCED, BASIC\n    require_tool_signatures=True,\n    # enable_behavior_monitoring=True, # Removed conceptual flag\n    enable_call_chain_validation=True,\n    max_call_depth=5,\n    audit_all_calls=True,\n    # allowed_callers, blocked_callees etc.\n)\n\n# Example OAuth Handler Configuration (Conceptual for server-side)\n# auth_handler = OAuthHandler(\n#     provider=\"auth0\", \n#     domain=\"your.domain.com\", \n#     client_id=\"clientid\", \n#     # ... other params\n# )\n\nserver = SecureServer(\n    name=\"my-super-secure-server\",\n    security_policy=policy,\n    # oauth_handlers=[auth_handler] # Registering OAuth middleware if applicable\n)\n\n@server.tool(\n    \"my_secure_tool\", \n    permissions=[\"data:read\", \"user:profile:view\"],\n    etdi_require_signature=True, # Overrides policy for this tool\n    etdi_max_call_depth=3\n)\nasync def my_secure_tool_impl(param: str):\n    # Tool logic\n    return f\"Processed {param} securely\"\n</code></pre> <p>These features provide a robust framework for building secure and trustworthy AI agent and tool ecosystems. Refer to specific examples in the project's <code>examples/etdi</code> directory and the API reference for detailed implementation guides.</p>"},{"location":"attack-prevention/rug-poisoning/","title":"ETDI Rug Poisoning Protection","text":""},{"location":"attack-prevention/rug-poisoning/#overview","title":"Overview","text":"<p>This page explains how the Enhanced Tool Definition Interface (ETDI) protects against Rug Poisoning attacks (also known as \"rug pulls\"). This type of attack occurs when a previously approved and trusted tool is maliciously or unexpectedly altered after users have come to rely on it, leading to potential data breaches, financial loss, or system compromise.</p>"},{"location":"attack-prevention/rug-poisoning/#attack-scenario","title":"Attack Scenario","text":""},{"location":"attack-prevention/rug-poisoning/#the-problem-rug-poisoning","title":"The Problem: Rug Poisoning","text":"<p>Rug Poisoning typically involves these stages:</p> <ol> <li>Initial Trust: A seemingly legitimate tool is published and approved by users/organizations. It functions as expected, gaining trust over time.</li> <li>Malicious Update/Swap: The tool provider (or a compromised account with publishing rights) updates the tool with malicious code. This could be a subtle change that exfiltrates data or a more drastic alteration of its core functionality. Alternatively, the tool's underlying infrastructure or dependencies might be swapped.</li> <li>Continued Use: Users and automated systems continue to invoke the tool, unaware of the malicious changes, as the tool's identifier or name might remain the same.</li> <li>Exploitation: The malicious version of the tool executes, leading to compromised data, unauthorized actions, or system instability.</li> </ol>"},{"location":"attack-prevention/rug-poisoning/#real-world-impact","title":"Real-World Impact","text":"<ul> <li>Data Exfiltration: Sensitive user or company data can be silently stolen.</li> <li>Unauthorized Actions: The tool might perform actions beyond its original scope, like financial transactions or data deletion.</li> <li>Loss of Service/Trust: If the tool's functionality is broken or behaves erratically, it can disrupt workflows and erode trust in the tool ecosystem.</li> <li>Compliance Violations: Unauthorized data access or modification can lead to severe compliance breaches.</li> </ul>"},{"location":"attack-prevention/rug-poisoning/#how-etdi-prevents-rug-poisoning","title":"How ETDI Prevents Rug Poisoning","text":"<p>ETDI employs a multi-layered defense strategy to detect and mitigate rug poisoning attacks:</p>"},{"location":"attack-prevention/rug-poisoning/#1-immutable-tool-versioning-cryptographic-hashing","title":"1. Immutable Tool Versioning &amp; Cryptographic Hashing","text":"<ul> <li>Concept: Every version of an ETDI tool definition (including its code, schema, permissions, and security policies) is cryptographically hashed. This hash acts as a unique, immutable fingerprint for that specific version.</li> <li>Protection: If any part of the tool definition changes, the hash will change. ETDI clients can verify that the tool they are about to invoke matches the hash of the version they previously approved.</li> <li>Example:     <pre><code># Conceptual client-side check\napproved_tool_version = \"1.0.0\"\napproved_tool_hash = \"sha256-abc123xyz789...\" # Hash of Tool v1.0.0\n\n# Client discovers tool 'SuperTool' v1.0.0 from server\n# Server provides tool definition for 'SuperTool' v1.0.0\ncurrent_tool_hash = calculate_hash(tool_definition_from_server) # Conceptual hash calculation\n\nif current_tool_hash != approved_tool_hash:\n    raise SecurityError(f\"Tool 'SuperTool' v{approved_tool_version} has changed since approval! Possible rug pull.\")\nelse:\n    # Proceed with invocation\n    print(\"Tool version and integrity verified.\")\n</code></pre></li> <li>Relevant ETDI Features: <code>ToolDefinition.version</code>. The hash is implicitly part of the signature and verification process. See Security Features for details on tool verification.</li> </ul>"},{"location":"attack-prevention/rug-poisoning/#2-change-detection-re-approval-workflow","title":"2. Change Detection &amp; Re-approval Workflow","text":"<ul> <li>Concept: ETDI clients maintain a record of approved tools and their specific versions/hashes. If a tool provider updates a tool, even if the version number appears the same or is incremented, the change in hash will be detected.</li> <li>Protection: Upon detecting a change, the ETDI client automatically revokes the existing approval for that tool. The user (or an automated policy) must explicitly re-approve the new version after reviewing the changes.</li> <li>Relevant ETDI Features: Client-side approval management, enforced by <code>ETDIClient.approve_tool()</code> and its underlying verification logic.</li> </ul>"},{"location":"attack-prevention/rug-poisoning/#3-strict-permission-and-scope-enforcement","title":"3. Strict Permission and Scope Enforcement","text":"<ul> <li>Concept: Tools declare the permissions they require (e.g., <code>file:read</code>, <code>api:user_data:write</code>). These permissions are part of the signed tool definition.</li> <li>Protection: Even if a tool's code is maliciously altered to attempt actions beyond its declared permissions, the ETDI framework (both client and potentially server-side middleware) will block such attempts if they don't align with the granted OAuth scopes or tool permissions.</li> <li>Example: A tool originally approved for <code>read-only</code> access cannot suddenly start writing data if its code is changed, as the permission grant is tied to the original, verified definition.</li> <li>Relevant ETDI Features: <code>ToolDefinition.permissions</code>, OAuth scope validation. See Authentication &amp; Authorization in Security Features.</li> </ul>"},{"location":"attack-prevention/rug-poisoning/#4-comprehensive-audit-trails","title":"4. Comprehensive Audit Trails","text":"<ul> <li>Concept: All significant security events, including tool discovery, verification, approval, invocation, and any detected modification or policy violation, are logged.</li> <li>Protection: Audit logs provide a clear history of tool interactions and changes. In the event of a suspected rug pull, these logs are crucial for forensic analysis to understand when the change occurred, what data might have been affected, and how the malicious tool was invoked.</li> <li>Relevant ETDI Features: Security event logging by <code>ETDIClient</code> and <code>SecureServer</code>.</li> </ul>"},{"location":"attack-prevention/rug-poisoning/#best-practices-for-users-and-developers","title":"Best Practices for Users and Developers","text":"<ul> <li>Users:<ul> <li>Always review permission changes before re-approving a tool.</li> <li>Be cautious if a tool frequently changes or requests new, broad permissions.</li> <li>Monitor audit logs if available.</li> </ul> </li> <li>Developers (Tool Providers):<ul> <li>Follow semantic versioning strictly.</li> <li>Clearly document changes between tool versions.</li> <li>Minimize the permissions requested by your tools (principle of least privilege).</li> <li>Secure your publishing credentials and development pipeline to prevent unauthorized tool updates.</li> </ul> </li> </ul>"},{"location":"attack-prevention/rug-poisoning/#conclusion","title":"Conclusion","text":"<p>ETDI's combination of cryptographic verification, immutable versioning, mandatory re-approval workflows for any changes, and strict permission enforcement provides robust protection against rug poisoning attacks. By ensuring that users are always aware of and explicitly consent to the version of the tool they are using, ETDI maintains the integrity and trustworthiness of the tool ecosystem.</p>"},{"location":"attack-prevention/rug-poisoning/#related-documentation","title":"Related Documentation","text":"<ul> <li>Tool Poisoning Prevention</li> <li>Overall Attack Prevention Strategies</li> <li>Security Features Overview</li> </ul>"},{"location":"attack-prevention/tool-poisoning/","title":"Tool Poisoning Attack Prevention","text":""},{"location":"attack-prevention/tool-poisoning/#what-is-tool-poisoning","title":"What is Tool Poisoning?","text":"<p>Tool Poisoning is a significant security threat in systems that utilize external or dynamically loaded tools, particularly in AI and Large Language Model (LLM) ecosystems. It occurs when a malicious actor successfully deploys a tool that masquerades as a legitimate, trusted tool. The aim is to deceive users, or the LLM itself, into executing the malicious tool, leading to various harmful outcomes.</p>"},{"location":"attack-prevention/tool-poisoning/#attack-vectors","title":"Attack Vectors","text":"<ol> <li>Identity Spoofing: The malicious tool uses a name, description, or provider information identical or very similar to a known trusted tool.</li> <li>Deceptive Functionality: The tool might appear to perform its advertised function correctly for simple cases, while secretly carrying out malicious activities in the background or for specific inputs.</li> <li>Lack of Verification: Systems that don't rigorously verify tool authenticity, origin, or integrity are vulnerable.</li> </ol>"},{"location":"attack-prevention/tool-poisoning/#potential-impacts","title":"Potential Impacts","text":"<ul> <li>Data Theft: Exfiltration of sensitive information, PII, credentials, or proprietary data processed by the tool.</li> <li>Malware Execution: Running arbitrary code on the host system or within the user's environment.</li> <li>Privilege Escalation: Gaining unauthorized access or higher privileges within the system.</li> <li>Denial of Service (DoS): Disrupting the availability of the system or legitimate tools.</li> <li>Compromise of LLM Integrity: Manipulating LLM outputs, behavior, or decision-making processes.</li> <li>Supply Chain Attacks: If the poisoned tool is itself a development or integration tool, it can compromise a wider ecosystem.</li> </ul>"},{"location":"attack-prevention/tool-poisoning/#etdis-mitigation-strategies","title":"ETDI's Mitigation Strategies","text":"<p>The Enhanced Tool Definition Interface (ETDI) provides a robust framework to combat tool poisoning attacks through multiple layers of security:</p> <ol> <li> <p>Cryptographic Signatures &amp; Verification:</p> <ul> <li>Authenticity: Tools are cryptographically signed by their providers. ETDI clients verify these signatures against trusted provider public keys before execution.</li> <li>Integrity: The signature ensures that the tool's definition and metadata have not been tampered with since publication.</li> </ul> </li> <li> <p>Provider Authentication &amp; Trust Management:</p> <ul> <li>OAuth 2.0 Integration: ETDI encourages tools to be protected by OAuth 2.0, ensuring that the tool provider is authenticated.</li> <li>Trusted Provider Registry (Conceptual): Systems can maintain a list of trusted provider identities and their corresponding public keys.</li> </ul> </li> <li> <p>Rich Security Metadata:</p> <ul> <li>ETDI tool definitions include comprehensive security metadata, such as required permissions (scopes), call stack constraints, and data handling policies.</li> <li>Clients can analyze this metadata before tool execution to assess risk and enforce policies.</li> </ul> </li> <li> <p>Client-Side Security Analysis Engine:</p> <ul> <li>ETDI clients incorporate a security analysis engine that evaluates tools based on their ETDI compliance, signature validity, OAuth protection, and other security attributes.</li> <li>This engine can assign trust scores and make informed decisions (allow, warn, block) about tool execution.</li> </ul> </li> <li> <p>Secure Tool Discovery &amp; Invocation Workflow:</p> <ul> <li>Discovery: Clients prioritize tools with strong ETDI security signals.</li> <li>Verification: Mandatory verification steps before a tool is considered for execution.</li> <li>Approval (Optional): For sensitive operations or less trusted tools, user or administrative approval can be enforced.</li> </ul> </li> </ol>"},{"location":"attack-prevention/tool-poisoning/#best-practices-for-developers-and-users","title":"Best Practices for Developers and Users","text":"<ul> <li>Providers: Always sign your tools with a strong private key. Protect your tools with OAuth 2.0. Clearly define security metadata.</li> <li>Developers (integrating ETDI): Implement rigorous signature verification. Use the ETDI client's security analysis capabilities. Prefer tools with complete and verified ETDI metadata.</li> <li>Users: Be cautious of tools from unverified sources. Pay attention to warnings from ETDI-compliant clients.</li> </ul> <p>By combining these technical measures and best practices, ETDI significantly raises the bar against tool poisoning attacks, fostering a more secure and trustworthy tool ecosystem.</p>"},{"location":"attack-prevention/tool-poisoning/#related-documentation","title":"Related Documentation","text":"<ul> <li>Overall Attack Prevention Strategies</li> <li>Rug Poisoning Protection</li> <li>Security Features Overview</li> <li>Tool Poisoning Demo Example</li> <li>Integration Guide</li> <li>FastMCP Security </li> </ul>"},{"location":"examples/","title":"Python SDK ETDI Examples","text":"<p>This section provides various examples demonstrating the capabilities and usage of the Enhanced Tool Definition Interface (ETDI) Python SDK.</p>"},{"location":"examples/#categories","title":"Categories","text":"<ul> <li> <p>ETDI Core Examples: Demonstrations of core ETDI security features, server and client implementations, and specific attack prevention mechanisms. These examples showcase how ETDI enhances the security of tool-based interactions.</p> <ul> <li>Includes detailed walkthroughs of features like call stack security, OAuth integration, and cryptographic verification of tools.</li> <li>See individual example pages like <code>run_e2e_demo.md</code> or <code>basic_usage.md</code>.</li> </ul> </li> <li> <p>FastMCP Integration Example: Showcases how to integrate ETDI security features seamlessly with the FastMCP decorator API.</p> <ul> <li>Focuses on the ease of adding security flags like <code>etdi=True</code>, <code>etdi_permissions</code>, and call stack constraints directly in <code>@server.tool()</code> decorators.</li> </ul> </li> </ul>"},{"location":"examples/#overview-of-key-examples","title":"Overview of Key Examples","text":"<p>Below is a summary of some important examples. Please refer to the specific sub-sections linked above for a complete list and detailed explanations.</p>"},{"location":"examples/#end-to-end-security-demo","title":"End-to-End Security Demo","text":"<ul> <li>File: <code>examples/etdi/run_e2e_demo.py</code></li> <li>Documentation: <code>docs/examples/etdi/run_e2e_demo.md</code></li> <li>Description: A comprehensive demonstration of ETDI features, including attack prevention, secure client-server interaction, and enforcement of security policies.</li> </ul>"},{"location":"examples/#fastmcp-with-etdi","title":"FastMCP with ETDI","text":"<ul> <li>File: <code>examples/fastmcp/etdi_fastmcp_example.py</code></li> <li>Documentation: <code>docs/fastmcp/index.md</code></li> <li>Description: Illustrates how to easily enable and configure ETDI security measures (permissions, call stack limits) using FastMCP decorators.</li> </ul>"},{"location":"examples/#tool-poisoning-prevention","title":"Tool Poisoning Prevention","text":"<ul> <li>Directory: <code>examples/etdi/tool_poisoning_demo/</code></li> <li>Documentation: <code>docs/examples/etdi/tool_poisoning_demo.md</code></li> <li>Description: Demonstrates how ETDI prevents tool poisoning attacks by verifying tool authenticity and integrity.</li> </ul>"},{"location":"examples/#navigating-the-examples","title":"Navigating the Examples","text":"<ul> <li>Each major example or category has its own index page within the <code>docs/examples/</code> directory.</li> <li>Python source code for these examples can be found in the <code>examples/</code> directory at the root of the project.</li> <li>The documentation pages aim to explain the purpose, key features, and how to run each example.</li> </ul> <p>Explore these examples to gain a practical understanding of how to leverage the ETDI Python SDK for building secure and robust tool-enabled applications. </p>"},{"location":"examples/etdi/","title":"ETDI Examples - Enhanced Tool Definition Interface","text":"<p>This directory contains comprehensive examples demonstrating how ETDI (Enhanced Tool Definition Interface) transforms MCP from a development protocol into an enterprise-ready security platform.</p>"},{"location":"examples/etdi/#quick-start","title":"\ud83d\ude80 Quick Start","text":"<p>Run the complete end-to-end security demonstration:</p> <pre><code># Ensure you are in the project root directory\npython examples/etdi/run_e2e_demo.py\n</code></pre> <p>This will show ETDI blocking real security attacks including: - \u2705 Call chain restriction enforcement - \u2705 Call depth limit validation - \u2705 Permission scope verification</p>"},{"location":"examples/etdi/#example-files","title":"\ud83d\udcc1 Example Files","text":"<p>This section provides an overview of the ETDI examples. Each example has its own detailed documentation page.</p>"},{"location":"examples/etdi/#core-security-demonstrations","title":"Core Security Demonstrations","text":"<ul> <li><code>run_e2e_demo.py</code> - START HERE: Complete end-to-end demonstration showing ETDI blocking real attacks.</li> <li><code>e2e_secure_server.py</code> - Secure Banking Server: FastMCP server with ETDI security demonstrating enterprise-grade protection.</li> <li><code>e2e_secure_client.py</code> - Secure Banking Client: Client that safely interacts with ETDI-secured servers.</li> <li><code>legitimate_etdi_server.py</code>: Example of a legitimate, fully secured ETDI server used in demos.</li> </ul>"},{"location":"examples/etdi/#fastmcp-integration","title":"FastMCP Integration","text":"<ul> <li><code>etdi_fastmcp_example.py</code>: Shows how to enable ETDI security with simple boolean flags in FastMCP decorators. (Located in <code>examples/fastmcp/</code>)</li> </ul>"},{"location":"examples/etdi/#security-components-features","title":"Security Components &amp; Features","text":"<ul> <li><code>basic_usage.py</code> - ETDI Fundamentals: Basic ETDI tool creation and security analysis.</li> <li><code>oauth_providers.py</code> - Enterprise Authentication: OAuth 2.0 integration with enterprise identity providers.</li> <li><code>secure_server_example.py</code> - Advanced Server Security: Comprehensive server security with middleware and token management.</li> <li><code>inspector_example.py</code> - Security Analysis Tools: Demonstrates <code>SecurityAnalyzer</code> and <code>TokenDebugger</code>.</li> <li><code>demo_etdi.py</code>: Comprehensive demo of various ETDI features.</li> </ul>"},{"location":"examples/etdi/#call-stack-security","title":"Call Stack Security","text":"<ul> <li><code>call_stack_example.py</code> - Call Stack Verification: Demonstrates protocol-level call stack security.</li> <li><code>protocol_call_stack_example.py</code> - Protocol Integration: Shows how call stack constraints are embedded in tool definitions.</li> <li><code>caller_callee_authorization_example.py</code> - Authorization Matrix: Detailed caller/callee authorization demonstration.</li> </ul>"},{"location":"examples/etdi/#utility-setup-examples","title":"Utility &amp; Setup Examples","text":"<ul> <li><code>clean_api_example.py</code>: Clean API usage for ETDI tool registration and invocation.</li> <li><code>setup_etdi.py</code>: Script to assist in setting up the ETDI environment or initial configurations.</li> <li><code>test_complete_security.py</code>: Test suite for complete security validation.</li> <li><code>verify_implementation.py</code>: Verifies ETDI installation and configuration.</li> </ul>"},{"location":"examples/etdi/#specific-attack-demonstrations","title":"Specific Attack Demonstrations","text":"<ul> <li>Tool Poisoning Demo: Contains a live demonstration of tool poisoning attacks and ETDI's prevention mechanisms. (Corresponds to <code>examples/etdi/tool_poisoning_demo/</code>)</li> </ul>"},{"location":"examples/etdi/#security-features-demonstrated-across-examples","title":"\ud83d\udee1\ufe0f Security Features Demonstrated Across Examples","text":"<p>Many examples showcase these core ETDI capabilities:</p> <ol> <li>Tool Poisoning Prevention: Cryptographic signature verification, provider authentication, tool integrity validation.</li> <li>Rug Pull Attack Protection: Version locking, change detection, behavior verification, reapproval workflows. (See Rug Poisoning Documentation)</li> <li>Privilege Escalation Blocking: Permission scope enforcement, call chain restrictions, OAuth integration.</li> <li>Call Stack Security: Maximum depth limits, allowed/blocked callee lists, real-time verification.</li> <li>Enterprise Compliance: Comprehensive audit trails, automated compliance checking, security scoring and reporting.</li> </ol>"},{"location":"examples/etdi/#enterprise-use-cases-conceptual-code-snippets","title":"\ud83c\udfe2 Enterprise Use Cases (Conceptual Code Snippets)","text":"<p>These snippets illustrate how ETDI features might be applied in various sensitive contexts.</p>"},{"location":"examples/etdi/#financial-services","title":"Financial Services","text":"<pre><code>@server.tool(etdi=True, etdi_permissions=[\"trading:read\"])\ndef get_portfolio():  # Can only read, never trade\n    pass\n\n@server.tool(etdi=True, etdi_permissions=[\"trading:execute\"], \n             etdi_max_call_depth=1)  # Cannot chain to other tools\ndef execute_trade():  # Isolated, audited, verified\n    pass\n</code></pre>"},{"location":"examples/etdi/#healthcare","title":"Healthcare","text":"<pre><code>@server.tool(etdi=True, etdi_permissions=[\"patient:read:anonymized\"])\ndef research_query():  # Only anonymized data\n    pass\n\n@server.tool(etdi=True, etdi_permissions=[\"patient:read:identified\"],\n             etdi_allowed_callees=[])  # Cannot call other tools\ndef doctor_lookup():  # Isolated access to identified data\n    pass\n</code></pre>"},{"location":"examples/etdi/#governmentdefense","title":"Government/Defense","text":"<pre><code>@server.tool(etdi=True, etdi_permissions=[\"classified:secret\"],\n             etdi_blocked_callees=[\"network\", \"external\"])\ndef process_classified():  # Cannot leak data externally\n    pass\n</code></pre>"},{"location":"examples/etdi/#measurable-security-improvements-conceptual","title":"\ud83d\udcca Measurable Security Improvements (Conceptual)","text":"<ul> <li>90% fewer privilege escalation paths through call chain controls</li> <li>100% verification of tool authenticity through signatures</li> <li>50% faster security audits through automated trails</li> <li>Zero unauthorized data access through OAuth scopes</li> </ul>"},{"location":"examples/etdi/#getting-started-with-examples","title":"\ud83d\ude80 Getting Started with Examples","text":"<ol> <li>Run a demo: Navigate to the project root and execute an example script, e.g., <code>python examples/etdi/run_e2e_demo.py</code>.</li> <li>Explore FastMCP integration: See the FastMCP ETDI Integration page.</li> <li>Read detailed pages: Browse the specific documentation pages for each example linked above.</li> <li>Build secure tools: Use ETDI decorators and principles in your own servers, referring to these examples.</li> </ol>"},{"location":"examples/etdi/#key-benefits","title":"\ud83d\udca1 Key Benefits","text":"<p>For Developers: Security becomes as easy as adding <code>etdi=True</code> (with FastMCP) or using ETDI-aware server/client classes. For Enterprises: Meet compliance requirements out of the box with robust security controls. For Users: Trust that tools are verified and operate within constrained boundaries. For the Industry: Raise the security bar for all MCP implementations.</p> <p>ETDI transforms MCP from a development protocol into an enterprise-ready platform that can handle the most sensitive data and critical operations with confidence. </p>"},{"location":"examples/etdi/basic_usage/","title":"Basic ETDI Usage (<code>basic_usage.py</code>)","text":"<p>This page describes the <code>basic_usage.py</code> example. This script demonstrates fundamental ETDI client usage, including tool creation and basic security analysis.</p> <p>Further details about core ETDI types shown (e.g., <code>ETDIToolDefinition</code>, <code>CallStackConstraints</code>, <code>Permission</code>), how security analysis is performed, its purpose as a starting point, and how to run this example will be added here.</p>"},{"location":"examples/etdi/basic_usage/#code","title":"Code","text":"<pre><code># Contents of examples/etdi/basic_usage.py will be embedded or linked here.\n</code></pre> <p>See the Examples Overview for a list of all examples. </p>"},{"location":"examples/etdi/call_stack_example/","title":"Call Stack Example (<code>call_stack_example.py</code>)","text":"<p>This page describes the <code>call_stack_example.py</code>. This script demonstrates protocol-level call stack security and verification within ETDI.</p> <p>Further details about how constraints like max depth and allowed/blocked callees are applied and verified, its purpose in preventing privilege escalation, and how to run this example will be added here.</p>"},{"location":"examples/etdi/call_stack_example/#code","title":"Code","text":"<pre><code># Contents of examples/etdi/call_stack_example.py will be embedded or linked here.\n</code></pre> <p>See the Examples Overview for a list of all examples. </p>"},{"location":"examples/etdi/caller_callee_authorization_example/","title":"Caller/Callee Authorization Example (<code>caller_callee_authorization_example.py</code>)","text":"<p>This page describes the <code>caller_callee_authorization_example.py</code>. This script provides a detailed demonstration of caller/callee authorization policies in ETDI.</p> <p>Further details about how fine-grained, tool-specific, and bidirectional authorization rules are implemented and enforced, its purpose, and how to run this example will be added here.</p>"},{"location":"examples/etdi/caller_callee_authorization_example/#code","title":"Code","text":"<pre><code># Contents of examples/etdi/caller_callee_authorization_example.py will be embedded or linked here.\n</code></pre> <p>See the Examples Overview for a list of all examples. </p>"},{"location":"examples/etdi/clean_api_example/","title":"Clean API Example (<code>clean_api_example.py</code>)","text":"<p>This page describes the <code>clean_api_example.py</code>. This script demonstrates a clean and straightforward approach to ETDI tool registration and invocation.</p> <p>Further details about the API usage patterns shown, its purpose in illustrating best practices or simplified interaction, and how to run this example will be added here.</p>"},{"location":"examples/etdi/clean_api_example/#code","title":"Code","text":"<pre><code># Contents of examples/etdi/clean_api_example.py will be embedded or linked here.\n</code></pre> <p>See the Examples Overview for a list of all examples. </p>"},{"location":"examples/etdi/demo_etdi/","title":"Comprehensive ETDI Demo (<code>demo_etdi.py</code>)","text":"<p>This page describes the <code>demo_etdi.py</code> example. This script provides a comprehensive demonstration of various ETDI features.</p> <p>Further details about the range of features covered, the scenarios shown, its purpose as an overall showcase, and how to run this demo will be added here.</p>"},{"location":"examples/etdi/demo_etdi/#code","title":"Code","text":"<pre><code># Contents of examples/etdi/demo_etdi.py will be embedded or linked here.\n</code></pre> <p>See the Examples Overview for a list of all examples. </p>"},{"location":"examples/etdi/e2e_secure_client/","title":"End-to-End Secure Client Example (<code>e2e_secure_client.py</code>)","text":"<p>This page describes the <code>e2e_secure_client.py</code> example. This script sets up an ETDI-secured client that interacts with a secure server as part of the end-to-end demonstration.</p> <p>Further details about how this client performs tool discovery, verification, approval, and invocation, its role in the e2e demo, and how it's run will be added here.</p>"},{"location":"examples/etdi/e2e_secure_client/#code","title":"Code","text":"<pre><code># Contents of examples/etdi/e2e_secure_client.py will be embedded or linked here.\n</code></pre> <p>See the Examples Overview for a list of all examples. </p>"},{"location":"examples/etdi/e2e_secure_server/","title":"End-to-End Secure Server Example (<code>e2e_secure_server.py</code>)","text":"<p>This page describes the <code>e2e_secure_server.py</code> example. This script sets up an ETDI-secured server as part of the end-to-end demonstration.</p> <p>Further details about this server's configuration, the tools it exposes, specific security features enabled, its purpose in the e2e demo, and how it's run will be added here.</p>"},{"location":"examples/etdi/e2e_secure_server/#code","title":"Code","text":"<pre><code># Contents of examples/etdi/e2e_secure_server.py will be embedded or linked here.\n</code></pre> <p>See the Examples Overview for a list of all examples. </p>"},{"location":"examples/etdi/inspector_example/","title":"ETDI Inspector Tools Example (<code>inspector_example.py</code>)","text":"<p>This page describes the <code>inspector_example.py</code>. This script demonstrates the usage of ETDI's inspector tools, such as the <code>SecurityAnalyzer</code> and <code>TokenDebugger</code>.</p> <p>Further details about how to use these inspector tools, what security aspects they help analyze, their purpose, and how to run the example will be added here.</p>"},{"location":"examples/etdi/inspector_example/#code","title":"Code","text":"<pre><code># Contents of examples/etdi/inspector_example.py will be embedded or linked here.\n</code></pre> <p>See the Examples Overview for a list of all examples. </p>"},{"location":"examples/etdi/legitimate_etdi_server/","title":"Legitimate ETDI Server Example (<code>legitimate_etdi_server.py</code>)","text":"<p>This page describes the <code>legitimate_etdi_server.py</code> example.</p> <p>Further details about this example, its purpose, and how to run it will be added here.</p>"},{"location":"examples/etdi/legitimate_etdi_server/#code","title":"Code","text":"<pre><code># Contents of examples/etdi/legitimate_etdi_server.py will be embedded or linked here.\n</code></pre> <p>See the Examples Overview for a list of all examples. </p>"},{"location":"examples/etdi/oauth_providers/","title":"OAuth Providers Example (<code>oauth_providers.py</code>)","text":"<p>This page describes the <code>oauth_providers.py</code> example, which demonstrates how to configure and use different OAuth 2.0 providers with ETDI.</p> <p>Further details about this example, its purpose, key configurations shown (e.g., for Auth0, Okta, Azure AD), and how to run it will be added here.</p>"},{"location":"examples/etdi/oauth_providers/#code","title":"Code","text":"<pre><code># Contents of examples/etdi/oauth_providers.py will be embedded or linked here.\n</code></pre> <p>See the Examples Overview for a list of all examples. </p>"},{"location":"examples/etdi/protocol_call_stack_example/","title":"Protocol Call Stack Example (<code>protocol_call_stack_example.py</code>)","text":"<p>This page describes the <code>protocol_call_stack_example.py</code>. This script demonstrates how ETDI manages and enforces call stack constraints at the protocol level.</p> <p>Further details about call stack security features (max depth, allowed/blocked callees), how they are defined in tool metadata, their purpose in preventing attacks like privilege escalation, and how to run this example will be added here.</p>"},{"location":"examples/etdi/protocol_call_stack_example/#code","title":"Code","text":"<pre><code># Contents of examples/etdi/protocol_call_stack_example.py will be embedded or linked here.\n</code></pre> <p>See the Examples Overview for a list of all examples. </p>"},{"location":"examples/etdi/run_e2e_demo/","title":"End-to-End Demo (<code>run_e2e_demo.py</code>)","text":"<p>This page describes the <code>run_e2e_demo.py</code> example, which showcases a complete end-to-end scenario of ETDI's security features in action.</p> <p>Further details about what this demo covers (e.g., specific attacks prevented, features shown), its purpose, and how to run it will be added here.</p>"},{"location":"examples/etdi/run_e2e_demo/#code","title":"Code","text":"<pre><code># Contents of examples/etdi/run_e2e_demo.py will be embedded or linked here.\n</code></pre> <p>See the Examples Overview for a list of all examples. </p>"},{"location":"examples/etdi/secure_server_example/","title":"Secure Server Example (<code>secure_server_example.py</code>)","text":"<p>This page describes the <code>secure_server_example.py</code>. This script provides a comprehensive example of setting up an ETDI-secured server, including middleware and token management.</p> <p>Further details about the security configurations, tool registration, authentication and authorization mechanisms demonstrated, its purpose, and how to run this server example will be added here.</p>"},{"location":"examples/etdi/secure_server_example/#code","title":"Code","text":"<pre><code># Contents of examples/etdi/secure_server_example.py will be embedded or linked here.\n</code></pre> <p>See the Examples Overview for a list of all examples. </p>"},{"location":"examples/etdi/setup_etdi/","title":"ETDI Setup Example (<code>setup_etdi.py</code>)","text":"<p>This page describes the <code>setup_etdi.py</code> example script. This script likely demonstrates or assists in setting up the ETDI environment or initial configurations.</p> <p>Further details about what this setup script configures, its prerequisites, its purpose, and how to use it will be added here.</p>"},{"location":"examples/etdi/setup_etdi/#code","title":"Code","text":"<pre><code># Contents of examples/etdi/setup_etdi.py will be embedded or linked here.\n</code></pre> <p>See the Examples Overview for a list of all examples. </p>"},{"location":"examples/etdi/test_complete_security/","title":"Complete Security Test (<code>test_complete_security.py</code>)","text":"<p>This page describes the <code>test_complete_security.py</code> example. This script likely serves as a test suite to validate the comprehensive security features of ETDI.</p> <p>Further details about the specific security aspects tested, how to interpret the results, its purpose, and how to run these tests will be added here.</p>"},{"location":"examples/etdi/test_complete_security/#code","title":"Code","text":"<pre><code># Contents of examples/etdi/test_complete_security.py will be embedded or linked here.\n</code></pre> <p>See the Examples Overview for a list of all examples. </p>"},{"location":"examples/etdi/tool_poisoning_demo/","title":"ETDI Tool Poisoning Prevention Demo","text":""},{"location":"examples/etdi/tool_poisoning_demo/#overview","title":"Overview","text":"<p>This demonstration shows how ETDI (Enhanced Tool Definition Interface) prevents Tool Poisoning attacks - a critical security vulnerability where malicious actors deploy tools that masquerade as legitimate, trusted tools to deceive users and LLMs.</p> <p>This page is based on the <code>TOOL_POISONING_DEMO_README.md</code> found in the <code>examples/etdi/tool_poisoning_demo/</code> directory (relative to project root).</p>"},{"location":"examples/etdi/tool_poisoning_demo/#attack-scenario","title":"Attack Scenario","text":""},{"location":"examples/etdi/tool_poisoning_demo/#the-problem-tool-poisoning","title":"The Problem: Tool Poisoning","text":"<p>Tool Poisoning occurs when: 1. Malicious Actor deploys a tool with identical name/description to a legitimate tool 2. Spoofed Identity - Claims to be from a trusted provider (e.g., \"TrustedSoft Inc.\") 3. Deceptive Behavior - Appears to function normally but secretly exfiltrates data 4. User/LLM Deception - No way to distinguish between legitimate and malicious tools</p>"},{"location":"examples/etdi/tool_poisoning_demo/#real-world-impact","title":"Real-World Impact","text":"<ul> <li>Data Theft - Sensitive documents, PII, credentials stolen</li> <li>Malware Installation - Malicious code execution</li> <li>Financial Loss - Unauthorized transactions, account compromise</li> <li>Privacy Violations - Personal information exposure</li> <li>Supply Chain Attacks - Compromised development tools</li> </ul>"},{"location":"examples/etdi/tool_poisoning_demo/#demo-components","title":"Demo Components","text":"<p>Details about the legitimate tool, malicious tool, and secure client used in this demo are available in the original README and the demo script (<code>tool_poisoning_prevention_demo.py</code> in <code>examples/etdi/tool_poisoning_demo/</code>).</p>"},{"location":"examples/etdi/tool_poisoning_demo/#1-legitimate-etdi-protected-tool","title":"1. Legitimate ETDI-Protected Tool","text":"<p>TrustedSoft SecureDocs Scanner - Legitimate document scanner with ETDI security, OAuth protection, call stack constraints, permission scoping, and audit logging.</p>"},{"location":"examples/etdi/tool_poisoning_demo/#2-malicious-tool-attack-simulation","title":"2. Malicious Tool (Attack Simulation)","text":"<p>Fake SecureDocs Scanner - Malicious tool lacking ETDI/OAuth, spoofing provider name, exfiltrating data, and returning fake results.</p>"},{"location":"examples/etdi/tool_poisoning_demo/#3-etdi-secure-client","title":"3. ETDI Secure Client","text":"<p>Security Analysis Engine that discovers tools, analyzes security (ETDI &amp; OAuth), prevents attacks, and reports results.</p>"},{"location":"examples/etdi/tool_poisoning_demo/#how-etdi-prevents-the-attack","title":"How ETDI Prevents the Attack","text":"<p>ETDI prevents this through a multi-stage verification process, typically involving checking for ETDI metadata, cryptographic signatures, OAuth protection, and provider identity.</p>"},{"location":"examples/etdi/tool_poisoning_demo/#trust-levels-decisions-conceptual","title":"Trust Levels &amp; Decisions (Conceptual)","text":"<ul> <li>TRUSTED (e.g., 80-100 points) \u2192 \u2705 ALLOW execution</li> <li>PARTIALLY_TRUSTED (e.g., 50-79 points) \u2192 \u26a0\ufe0f WARN user</li> <li>UNTRUSTED (e.g., 0-49 points) \u2192 \ud83d\uded1 BLOCK execution</li> </ul>"},{"location":"examples/etdi/tool_poisoning_demo/#running-the-demo","title":"Running the Demo","text":""},{"location":"examples/etdi/tool_poisoning_demo/#prerequisites","title":"Prerequisites","text":"<pre><code># Ensure you're in the project root directory\n# Activate your virtual environment, e.g.:\n# source .venv/bin/activate \ncd examples/etdi/tool_poisoning_demo # Navigate to the demo directory\n</code></pre>"},{"location":"examples/etdi/tool_poisoning_demo/#execute-demo","title":"Execute Demo","text":"<pre><code>python tool_poisoning_prevention_demo.py\n</code></pre> <p>(Refer to the original README in the demo directory for the most up-to-date execution instructions and expected output.)</p>"},{"location":"examples/etdi/tool_poisoning_demo/#key-insights","title":"Key Insights","text":""},{"location":"examples/etdi/tool_poisoning_demo/#without-etdi","title":"Without ETDI","text":"<ul> <li>No reliable verification method.</li> <li>Easy to spoof tool identities.</li> <li>No inherent authentication of the tool provider.</li> <li>Silent attacks can go undetected.</li> </ul>"},{"location":"examples/etdi/tool_poisoning_demo/#with-etdi","title":"With ETDI","text":"<ul> <li>Cryptographic verification of tool authenticity.</li> <li>OAuth protection for provider identity verification.</li> <li>Security metadata available for analysis before execution.</li> <li>Malicious tools can be blocked proactively.</li> </ul>"},{"location":"examples/etdi/tool_poisoning_demo/#conclusion","title":"Conclusion","text":"<p>ETDI's security framework provides the cryptographic proof and verification mechanisms needed to prevent tool poisoning attacks and protect sensitive data.</p>"},{"location":"examples/etdi/tool_poisoning_demo/#related-documentation","title":"Related Documentation","text":"<ul> <li>Overall Attack Prevention Strategies</li> <li>Rug Poisoning Protection</li> <li>Security Features Overview</li> <li>ETDI Examples Overview </li> </ul>"},{"location":"examples/etdi/verify_implementation/","title":"Implementation Verification (<code>verify_implementation.py</code>)","text":"<p>This page describes the <code>verify_implementation.py</code> example. This script is used to verify that the ETDI framework is properly installed, configured, and behaving as expected in the current environment.</p> <p>Further details about what checks this script performs, its expected output for a successful verification, its purpose, and how to run it will be added here.</p>"},{"location":"examples/etdi/verify_implementation/#code","title":"Code","text":"<pre><code># Contents of examples/etdi/verify_implementation.py will be embedded or linked here.\n</code></pre> <p>See the Examples Overview for a list of all examples. </p>"},{"location":"fastmcp/","title":"FastMCP with ETDI Integration Example","text":"<p>This page details how to integrate Enhanced Tool Definition Interface (ETDI) security features with the FastMCP decorator API. ETDI security can be enabled and configured using simple boolean flags and parameters directly within the <code>@server.tool()</code> decorator.</p> <p>This approach allows for a declarative way to specify security requirements such as permissions, call stack constraints, and overall ETDI enablement for your tools.</p>"},{"location":"fastmcp/#example-overview","title":"Example Overview","text":"<p>The <code>examples/fastmcp/etdi_fastmcp_example.py</code> script (relative to project root) demonstrates these capabilities.</p> <pre><code>#!/usr/bin/env python3\n\"\"\"\nFastMCP with ETDI Integration Example\n\nDemonstrates how to use the FastMCP decorator API with ETDI security features\nenabled through simple boolean flags and parameters.\n\"\"\"\n\nfrom mcp.server.fastmcp import FastMCP\n\n# Create FastMCP server\nserver = FastMCP(\"ETDI FastMCP Example\")\n\n\n@server.tool()\ndef basic_tool(x: int) -&gt; str:\n    \"\"\"A basic tool without ETDI security\"\"\"\n    return f\"Basic result: {x}\"\n\n\n@server.tool(etdi=True)\ndef simple_etdi_tool(message: str) -&gt; str:\n    \"\"\"A simple tool with ETDI security enabled\"\"\"\n    return f\"ETDI secured: {message}\"\n\n\n@server.tool(\n    etdi=True,\n    etdi_permissions=[\"data:read\", \"files:access\"],\n    etdi_max_call_depth=3\n)\ndef secure_data_tool(data_id: str) -&gt; str:\n    \"\"\"A tool with specific ETDI permissions and call depth limits\"\"\"\n    return f\"Securely processed data: {data_id}\"\n\n\n@server.tool(\n    etdi=True,\n    etdi_permissions=[\"files:write\", \"storage:modify\"],\n    etdi_allowed_callees=[\"secure_data_tool\", \"validation_tool\"],\n    etdi_blocked_callees=[\"admin_tool\", \"dangerous_tool\"]\n)\ndef file_processor(filename: str, content: str) -&gt; str:\n    \"\"\"A tool with call chain restrictions\"\"\"\n    return f\"File {filename} processed with ETDI call chain security\"\n\n\n@server.tool(\n    etdi=True,\n    etdi_permissions=[\"admin:read\"],\n    etdi_max_call_depth=1,\n    etdi_allowed_callees=[]  # Cannot call any other tools\n)\ndef admin_info_tool(query: str) -&gt; str:\n    \"\"\"Administrative tool with strict ETDI constraints\"\"\"\n    return f\"Admin info (secured): {query}\"\n\n\n@server.tool(\n    etdi=True,\n    etdi_permissions=[\"validation:execute\"],\n    etdi_max_call_depth=2\n)\ndef validation_tool(data: str) -&gt; str:\n    \"\"\"Validation tool that can be called by other tools\"\"\"\n    return f\"Validated: {data}\"\n\n\n# Example of a tool that would be dangerous without ETDI\n@server.tool(\n    etdi=True,\n    etdi_permissions=[\"system:execute\", \"admin:full\"],\n    etdi_max_call_depth=1,\n    etdi_blocked_callees=[\"*\"]  # Cannot call any tools\n)\ndef system_command_tool(command: str) -&gt; str:\n    \"\"\"System command tool with maximum ETDI security\"\"\"\n    # In a real implementation, this would execute system commands\n    # ETDI ensures it can't be called inappropriately or call other tools\n    return f\"System command executed securely: {command}\"\n\n\ndef main():\n    \"\"\"Demonstrate the ETDI-enabled FastMCP server\"\"\"\n    print(\"\ud83d\ude80 FastMCP with ETDI Integration Example\")\n    print(\"=\" * 50)\n\n    print(\"\\n\ud83d\udccb Tools registered:\")\n\n    # Get all registered tools\n    tools = server._tool_manager.list_tools()\n\n    for tool in tools:\n        tool_name = tool.name\n        # Check if the original function has ETDI metadata\n        original_func = getattr(server._tool_manager._tools.get(tool_name), '_original_function', None)\n\n        if hasattr(original_func, '_etdi_enabled') and original_func._etdi_enabled:\n            etdi_tool = getattr(original_func, '_etdi_tool_definition', None)\n            print(f\"\\n\ud83d\udd12 {tool_name} (ETDI Secured)\")\n            print(f\"   Description: {tool.description}\")\n\n            if etdi_tool:\n                if etdi_tool.permissions:\n                    perms = [p.scope for p in etdi_tool.permissions]\n                    print(f\"   Permissions: {', '.join(perms)}\")\n\n                if etdi_tool.call_stack_constraints:\n                    constraints = etdi_tool.call_stack_constraints\n                    if constraints.max_depth:\n                        print(f\"   Max Call Depth: {constraints.max_depth}\")\n                    if constraints.allowed_callees:\n                        print(f\"   Allowed Callees: {', '.join(constraints.allowed_callees)}\")\n                    if constraints.blocked_callees:\n                        print(f\"   Blocked Callees: {', '.join(constraints.blocked_callees)}\")\n        else:\n            print(f\"\\n\ud83d\udcdd {tool_name} (Standard)\")\n            print(f\"   Description: {tool.description}\")\n\n    print(\"\\n\" + \"=\" * 50)\n    print(\"\u2705 FastMCP ETDI Integration Complete!\")\n    print(\"\\n\ud83d\udca1 Key Benefits:\")\n    print(\"   \u2022 Simple boolean flag to enable ETDI security\")\n    print(\"   \u2022 Declarative permission specification\")\n    print(\"   \u2022 Call stack depth and chain controls\")\n    print(\"   \u2022 Automatic ETDI tool definition generation\")\n    print(\"   \u2022 Seamless integration with existing FastMCP code\")\n    print(\"   \u2022 Graceful fallback when ETDI not available\")\n\n    print(\"\\n\ud83d\udd27 Usage Examples:\")\n    print(\"   @server.tool(etdi=True)\")\n    print(\"   @server.tool(etdi=True, etdi_permissions=['data:read'])\")\n    print(\"   @server.tool(etdi=True, etdi_max_call_depth=3)\")\n    print(\"   @server.tool(etdi=True, etdi_allowed_callees=['helper'])\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"fastmcp/#key-features-demonstrated","title":"Key Features Demonstrated","text":"<ul> <li>Enabling ETDI: Simply add <code>etdi=True</code> to the <code>@server.tool()</code> decorator.     <pre><code>@server.tool(etdi=True)\ndef simple_etdi_tool(message: str) -&gt; str: # ...\n</code></pre></li> <li>Specifying Permissions: Use the <code>etdi_permissions</code> list to declare required OAuth scopes.     <pre><code>@server.tool(\n    etdi=True,\n    etdi_permissions=[\"data:read\", \"files:access\"]\n)\ndef secure_data_tool(data_id: str) -&gt; str: # ...\n</code></pre></li> <li>Setting Call Stack Constraints:<ul> <li><code>etdi_max_call_depth</code>: Integer defining maximum call chain depth.</li> <li><code>etdi_allowed_callees</code>: List of tool names that this tool is allowed to invoke.</li> <li><code>etdi_blocked_callees</code>: List of tool names that this tool is explicitly forbidden from invoking (can use <code>[\"*\"]</code> to block all calls). <pre><code>@server.tool(\n    etdi=True,\n    etdi_permissions=[\"files:write\", \"storage:modify\"],\n    etdi_allowed_callees=[\"secure_data_tool\", \"validation_tool\"],\n    etdi_blocked_callees=[\"admin_tool\", \"dangerous_tool\"]\n)\ndef file_processor(filename: str, content: str) -&gt; str: # ...\n</code></pre></li> </ul> </li> </ul>"},{"location":"fastmcp/#benefits","title":"Benefits","text":"<ul> <li>Simplified Security: Security features are declared alongside the tool definition, making it easy to understand and manage.</li> <li>Automatic ETDI Definition: FastMCP handles the creation of the underlying <code>ETDIToolDefinition</code> object based on these parameters.</li> <li>Seamless Integration: Works with existing FastMCP server and tool structures with minimal changes.</li> <li>Graceful Fallback: If the ETDI client or server does not support these specific ETDI extensions, the tool may still function as a standard MCP tool (behavior might depend on MCP library specifics).</li> </ul> <p>By using these decorator parameters, you can incrementally add robust ETDI security to your FastMCP tools.</p>"},{"location":"fastmcp/#related-documentation","title":"Related Documentation","text":"<ul> <li>Attack Prevention Overview</li> <li>Call Stack Security</li> <li>Security Features Overview </li> </ul>"}]}